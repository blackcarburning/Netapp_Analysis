
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ONTAP CLI Delimited → XLSX Exporter (Offline + Charts)</title>
  <style>
    :root { --bg:#0b1020; --card:#121a33; --text:#e9eefc; --muted:#a9b4d6; --accent:#7aa2ff; --border:#23305a; }
    * { box-sizing: border-box; }
    body {
      margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: linear-gradient(180deg, #070a14, var(--bg));
      color: var(--text);
    }
    header { padding: 26px 18px 12px; max-width: 1200px; margin: 0 auto; }
    h1 { margin: 0 0 8px; font-size: 20px; }
    p { margin: 6px 0; color: var(--muted); line-height: 1.35; }
    .grid {
      max-width: 1200px; margin: 0 auto; padding: 12px 18px 28px;
      display: grid; grid-template-columns: 390px 1fr; gap: 14px;
    }
    @media (max-width: 980px) { .grid { grid-template-columns: 1fr; } }
    .card {
      background: rgba(18,26,51,0.92);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 10px 22px rgba(0,0,0,0.35);
    }
    .card h2 { margin: 0 0 10px; font-size: 13px; text-transform: uppercase; letter-spacing: .08em; color: #cfe0ff; }
    label { display: block; font-size: 12px; color: var(--muted); margin: 0 0 6px; }
    input[type="text"], input[type="number"], select, textarea {
      width: 100%;
      background: #0c132b;
      color: var(--text);
      border: 1px solid #22305a;
      border-radius: 10px;
      padding: 10px 10px;
      outline: none;
    }
    textarea {
      resize: vertical;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px; line-height: 1.4;
    }
    .out { min-height: 240px; }
    .paste { min-height: 160px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .row3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
    .btns { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px; align-items: center; }
    button {
      border: 1px solid #2b3a6a;
      background: linear-gradient(180deg, #1a2a5c, #121b3b);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
      white-space: nowrap;
    }
    button.secondary { background: transparent; }
    button:hover { border-color: var(--accent); }
    .hint {
      margin-top: 10px;
      padding: 10px 12px;
      border: 1px dashed #2b3a6a;
      border-radius: 12px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }
    .warn {
      margin-top: 10px;
      padding: 10px 12px;
      border: 1px solid #7a3b3b;
      border-radius: 12px;
      background: rgba(122,59,59,0.15);
      color: #ffd7d7;
      font-size: 12px;
      line-height: 1.35;
      display: none;
    }
    .section {
      border: 1px solid #22305a;
      border-radius: 14px;
      background: rgba(12,19,43,0.55);
      padding: 12px;
      margin-top: 12px;
    }
    .section h3 { margin: 0 0 8px; font-size: 14px; }
    .section .meta { font-size: 12px; color: var(--muted); margin-bottom: 8px; }
    .mini { font-size: 12px; color: var(--muted); }
    code.kbd { background: #0c132b; border: 1px solid #22305a; padding: 1px 6px; border-radius: 8px; }
    canvas { width: 100% !important; height: 320px !important; background: rgba(12,19,43,0.25); border-radius: 12px; border: 1px solid #22305a; }
    .tiny { font-size: 11px; color: var(--muted); }

    /* Field picker UI */
    details.picker {
      margin-top: 8px;
      border: 1px solid #22305a;
      border-radius: 12px;
      background: rgba(12,19,43,0.35);
      overflow: hidden;
    }
    details.picker > summary {
      cursor: pointer;
      list-style: none;
      padding: 10px 12px;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      color: #cfe0ff;
      font-size: 12px;
    }
    details.picker > summary::-webkit-details-marker { display: none; }
    .pickerBody {
      padding: 10px 12px 12px;
      border-top: 1px solid #22305a;
    }
    .pickerTools {
      display: grid;
      grid-template-columns: 1fr auto auto;
      gap: 8px;
      align-items: center;
      margin-bottom: 10px;
    }
    .pickerTools input[type="text"] { padding: 8px 10px; }
    .pickerTools button { padding: 8px 10px; border-radius: 10px; }
    .pickerList {
      max-height: 260px;
      overflow: auto;
      border: 1px solid #22305a;
      border-radius: 12px;
      padding: 8px;
      background: rgba(12,19,43,0.25);
    }
    .pickItem {
      display: grid;
      grid-template-columns: 18px 1fr;
      gap: 8px;
      padding: 6px 6px;
      border-radius: 10px;
      align-items: start;
    }
    .pickItem:hover { background: rgba(122,162,255,0.08); }
    .pickField {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      color: #e9eefc;
    }
    .pickDesc {
      font-size: 11px;
      color: var(--muted);
      margin-top: 2px;
      line-height: 1.25;
    }
    .pill {
      font-size: 11px;
      color: var(--muted);
      border: 1px solid #22305a;
      border-radius: 999px;
      padding: 2px 8px;
      background: rgba(12,19,43,0.35);
      white-space: nowrap;
    }

    /* Units row */
    .unitsRow {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      margin-top: 10px;
    }

    /* Config row */
    .configRow {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 10px;
      align-items: center;
    }

    /* Detected unit badge */
    .unit-badge {
      display: inline-block;
      font-size: 10px;
      font-weight: 600;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(122,162,255,0.15);
      border: 1px solid rgba(122,162,255,0.4);
      color: #7aa2ff;
      white-space: nowrap;
      margin-left: 8px;
      vertical-align: middle;
    }
    .unit-badge.raw {
      background: rgba(255,170,100,0.15);
      border-color: rgba(255,170,100,0.4);
      color: #ffaa64;
    }
    .unit-badge.none {
      background: rgba(169,180,214,0.1);
      border-color: rgba(169,180,214,0.3);
      color: var(--muted);
    }
  </style>
</head>

<body>
<header>
  <h1>ONTAP CLI Delimited Output → XLSX Export (Offline) + Summary Charts</h1>
  <p>Generate the PuTTY block, run it on the cluster, paste (or import) each command’s output, then export to <code class="kbd">.xlsx</code> or graph key summary fields.</p>
  <p class="mini">Offline mode: this HTML expects <code class="kbd">xlsx.full.min.js</code> and <code class="kbd">chart.umd.min.js</code> in the same folder.</p>
</header>

<div class="grid">
  <!-- LEFT: generator -->
  <section class="card">
    <h2>Generate PuTTY block</h2>

    <div class="row">
      <div>
        <label for="delimiter">Delimiter used by ONTAP output</label>
        <select id="delimiter">
          <option value=",">Comma (,)</option>
          <option value="|">Pipe (|)</option>
          <option value=";">Semicolon (;)</option>
          <option value="\\t">Tab (\\t)</option>
        </select>
      </div>
      <div>
        <label for="commentPrefix">Section header prefix (comments)</label>
        <select id="commentPrefix">
          <option value="#">#</option>
          <option value="##">##</option>
          <option value="###">###</option>
        </select>
      </div>
    </div>

    <div style="height:10px"></div>

    <div class="row3">
      <div><label><input type="checkbox" id="showAllFields" checked /> set -showallfields true</label></div>
      <div>
        <label><input type="checkbox" id="unitsRaw" checked /> set -units raw</label>
        <div class="tiny" style="margin-top:4px;">(This is ONTAP CLI output formatting.)</div>
      </div>
      <div><label><input type="checkbox" id="rows0" checked /> rows 0</label></div>
    </div>

    <div class="unitsRow">
      <div>
        <label for="unitsSpecifier">Units specifier (best-effort)</label>
        <select id="unitsSpecifier">
          <option value="(none)">(none / don’t include)</option>
          <option value="raw">raw</option>
          <option value="kb">kb</option>
          <option value="mb">mb</option>
          <option value="gb">gb</option>
          <option value="tb">tb</option>
          <option value="pb">pb</option>
        </select>
        <div class="tiny" style="margin-top:6px;">
          If your ONTAP version doesn’t accept these, leave as <span class="kbd">raw</span> (via checkbox) or <span class="kbd">(none)</span>.
        </div>
      </div>
    </div>

    <div style="height:10px"></div>

    <div class="row">
      <div>
        <label for="svm">Optional SVM (vserver) filter</label>
        <input id="svm" type="text" placeholder="e.g. svm_data1 (blank = all)" />
      </div>
      <div>
        <label for="scope">Apply SVM filter</label>
        <select id="scope">
          <option value="whereSupported">Only on vserver-aware commands</option>
          <option value="everywhere">Attempt everywhere (might error)</option>
        </select>
      </div>
    </div>

    <div class="hint">
      Each command below has a field “dropdown” (tick boxes). Your selections are saved locally and restored on reload.
      The query block updates instantly as you change fields.
    </div>

    <div class="btns">
      <button id="btnGenerate">Generate</button>
      <button id="btnCopy" class="secondary">Copy block</button>
      <button id="btnReset" class="secondary">Reset</button>
    </div>

    <!-- Field configuration export/import (now includes pasted CSV boxes too) -->
    <div class="configRow">
      <button id="btnExportConfig" class="secondary">Export config+data (JSON)</button>
      <button id="btnImportConfig" class="secondary">Import config+data (JSON)</button>
      <input id="configFile" type="file" accept=".json,application/json" style="display:none" />
      <span class="tiny">Share settings + pasted outputs between systems.</span>
    </div>

    <div style="height:12px"></div>

    <label for="out">PuTTY paste block</label>
    <textarea id="out" class="out" spellcheck="false"></textarea>

    <h2 style="margin-top:14px;">Field sets (editable + tick-box picker)</h2>

    <label for="fieldsAggSpace">storage aggregate show-space -fields</label>
    <input id="fieldsAggSpace" type="text" />
    <div id="picker_fieldsAggSpace"></div>

    <div style="height:10px"></div>

    <label for="fieldsAggEfficiency">storage aggregate show-efficiency -fields</label>
    <input id="fieldsAggEfficiency" type="text" />
    <div id="picker_fieldsAggEfficiency"></div>

    <div style="height:10px"></div>

    <label for="fieldsVol">volume show -fields</label>
    <input id="fieldsVol" type="text" />
    <div id="picker_fieldsVol"></div>

    <div style="height:10px"></div>

    <label for="fieldsVolSpace">volume show-space -fields</label>
    <input id="fieldsVolSpace" type="text" />
    <div id="picker_fieldsVolSpace"></div>

    <div style="height:10px"></div>

    <label for="fieldsSnaps">volume snapshot show -fields</label>
    <input id="fieldsSnaps" type="text" />
    <div id="picker_fieldsSnaps"></div>

    <div style="height:10px"></div>

    <label for="fieldsEff">volume efficiency show -fields</label>
    <input id="fieldsEff" type="text" />
    <div id="picker_fieldsEff"></div>

    <div style="height:10px"></div>

    <label for="fieldsQtree">volume qtree show -fields</label>
    <input id="fieldsQtree" type="text" />
    <div id="picker_fieldsQtree"></div>

    <div style="height:10px"></div>

    <label for="fieldsLun">lun show -fields</label>
    <input id="fieldsLun" type="text" />
    <div id="picker_fieldsLun"></div>

    <div style="height:10px"></div>

    <label for="fieldsCifs">vserver cifs share show -fields</label>
    <input id="fieldsCifs" type="text" />
    <div id="picker_fieldsCifs"></div>

  </section>

  <!-- RIGHT: paste/import/export + charts -->
  <section class="card">
    <h2>Import / paste outputs + export</h2>

    <div class="warn" id="offlineWarn"></div>

    <div class="section">
      <h3>Quick import (CSV/TXT) into a section</h3>
      <div class="meta">Pick a target box, choose a file, and it will load into that textarea (offline).</div>
      <div class="row">
        <div>
          <label for="importTarget">Target</label>
          <select id="importTarget">
            <option value="pasteAggSpace">Aggregates (show-space)</option>
            <option value="pasteAggEfficiency">Aggregates (show-efficiency)</option>
            <option value="pasteVol">Volumes</option>
            <option value="pasteVolSpace">Vol_Show_Space</option>
            <option value="pasteSnaps">Snapshots</option>
            <option value="pasteEff">Efficiency</option>
            <option value="pasteQtree">Qtrees</option>
            <option value="pasteLun">LUNs</option>
            <option value="pasteCifs">CIFS_Shares</option>
          </select>
        </div>
        <div>
          <label for="importFile">Choose file</label>
          <input id="importFile" type="file" accept=".txt,.csv,.log" />
        </div>
      </div>
      <div class="btns">
        <button id="btnImport" class="secondary">Import into selected box</button>
        <span class="tiny">The file should contain the header row + data rows (delimited output).</span>
      </div>
    </div>

    <div class="section">
      <h3>PDF Report Settings</h3>
      <div class="row">
        <div>
          <label for="reportCustomerName">Customer Name</label>
          <input id="reportCustomerName" type="text" placeholder="e.g. Acme Corporation" />
        </div>
        <div>
          <label for="reportGeneratedBy">Generated By</label>
          <input id="reportGeneratedBy" type="text" placeholder="e.g. CSI Ltd" value="CSI Ltd" />
        </div>
      </div>
      <div style="height:10px"></div>
      <div>
        <label for="reportTitle">Report Title (optional)</label>
        <input id="reportTitle" type="text" placeholder="e.g. Storage Capacity Assessment" value="NetApp Storage Configuration Report" />
      </div>
    </div>

    <div class="btns">
      <button id="btnExportAll">Export ALL to one XLSX (multi-sheet)</button>
      <button id="btnGenerateReport" class="secondary">Generate PDF Report</button>
      <button id="btnClearAll" class="secondary">Clear all pasted outputs</button>
    </div>

    <div class="row" style="margin-top: 10px;">
      <div>
        <label for="xlsxUnitFrom">Convert from unit (XLSX)</label>
        <select id="xlsxUnitFrom">
          <option value="none">None (no conversion)</option>
          <option value="raw">Raw (bytes)</option>
          <option value="KB">KB</option>
          <option value="MB">MB</option>
          <option value="GB">GB</option>
          <option value="TB">TB</option>
          <option value="PB">PB</option>
        </select>
      </div>
      <div>
        <label for="xlsxUnitTo">Convert to unit (XLSX)</label>
        <select id="xlsxUnitTo">
          <option value="none">None (no conversion)</option>
          <option value="raw">Raw (bytes)</option>
          <option value="KB">KB</option>
          <option value="MB">MB</option>
          <option value="GB">GB</option>
          <option value="TB">TB</option>
          <option value="PB">PB</option>
        </select>
      </div>
    </div>
    <div class="tiny" style="margin-top:4px;">Conversion is applied to size-related columns. The from-unit is auto-detected from the data (e.g., GB, TB).</div>

    <div class="hint">
      Paste the ONTAP output for each command (including the header row). Lines starting with <code class="kbd">#</code> are ignored.
      If you copy extra blank lines, that’s fine.
      <br><br>
      For PDF reports, download <code class="kbd">jspdf.umd.min.js</code> from 
      <a href="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" target="_blank">cdnjs</a>
      and optionally <code class="kbd">jspdf.plugin.autotable.min.js</code> from
      <a href="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.1/jspdf.plugin.autotable.min.js" target="_blank">cdnjs</a>.
      Place them in the same folder as this HTML file.
    </div>

    <!-- CHARTS -->
    <div class="section" data-key="charts">
      <h3>Summary charts (offline)</h3>
      <div class="meta">Build a quick bar chart from one pasted section (Volumes is usually best).</div>

      <div class="row">
        <div>
          <label for="chartSource">Data source</label>
          <select id="chartSource">
            <option value="pasteVol">Volumes</option>
            <option value="pasteAggSpace">Aggregates (show-space)</option>
            <option value="pasteAggEfficiency">Aggregates (show-efficiency)</option>
            <option value="pasteVolSpace">Vol_Show_Space</option>
            <option value="pasteLun">LUNs</option>
          </select>
        </div>
        <div>
          <label for="chartTopN">Top N</label>
          <input id="chartTopN" type="number" min="1" max="200" value="20" />
        </div>
      </div>

      <div style="height:10px"></div>

      <div class="row">
        <div>
          <label for="chartLabelCol">Label column</label>
          <select id="chartLabelCol"></select>
        </div>
        <div>
          <label for="chartValueCol">Value column</label>
          <select id="chartValueCol"></select>
        </div>
      </div>

      <div style="height:10px"></div>

      <div class="row">
        <div>
          <label for="chartOrientation">Orientation</label>
          <select id="chartOrientation">
            <option value="horizontal">Horizontal bar</option>
            <option value="vertical">Vertical bar</option>
          </select>
        </div>
        <div>
          <label for="chartSort">Sort</label>
          <select id="chartSort">
            <option value="desc">Largest → smallest</option>
            <option value="asc">Smallest → largest</option>
          </select>
        </div>
      </div>

      <div style="height:10px"></div>

      <div class="row">
        <div>
          <label for="chartUnitFrom">Convert from unit</label>
          <select id="chartUnitFrom">
            <option value="none">None (no conversion)</option>
            <option value="raw">Raw (bytes)</option>
            <option value="KB">KB</option>
            <option value="MB">MB</option>
            <option value="GB">GB</option>
            <option value="TB">TB</option>
            <option value="PB">PB</option>
          </select>
        </div>
        <div>
          <label for="chartUnitTo">Convert to unit</label>
          <select id="chartUnitTo">
            <option value="none">None (no conversion)</option>
            <option value="raw">Raw (bytes)</option>
            <option value="KB">KB</option>
            <option value="MB">MB</option>
            <option value="GB">GB</option>
            <option value="TB">TB</option>
            <option value="PB">PB</option>
          </select>
        </div>
      </div>
      <div class="tiny" style="margin-top:4px;">
        <strong>How to use:</strong> 
        <ul style="margin: 4px 0; padding-left: 16px;">
          <li>If data has unit suffixes (e.g., "10GB"), it's auto-converted to bytes. Set "from" to <code>Raw (bytes)</code>.</li>
          <li>If data is plain numbers without suffixes, set "from" to match the unit used when collecting (e.g., if you ran with <code>set -units gb</code>, select <code>GB</code>).</li>
          <li>Set "to" to your desired display unit.</li>
        </ul>
      </div>

      <div class="btns">
        <button id="btnBuildChart">Build chart</button>
        <button id="btnClearChart" class="secondary">Clear chart</button>
        <button id="btnExportChartPng" class="secondary">Export chart to PNG</button>
        <span class="tiny">Tip: try <code class="kbd">percent-used</code>, <code class="kbd">used</code>, <code class="kbd">logical-used</code>, or <code class="kbd">size-used</code> (LUNs).</span>
      </div>

      <canvas id="chartCanvas"></canvas>
      <div class="tiny" id="chartStatus" style="margin-top:8px;"></div>
    </div>

    <!-- PASTE SECTIONS -->
    <div class="section" data-key="aggregates-space">
      <h3>Aggregates (show-space) <span class="unit-badge none" id="unitBadge_pasteAggSpace">No data</span></h3>
      <div class="meta">Paste output of: <code class="kbd">storage aggregate show-space -fields …</code></div>
      <textarea class="paste" id="pasteAggSpace" spellcheck="false" placeholder="Paste storage aggregate show-space output here…"></textarea>
      <div class="btns">
        <button class="btnExportOne" data-target="pasteAggSpace" data-sheet="Aggregates_Space">Export Aggregates_Space.xlsx</button>
      </div>
    </div>

    <div class="section" data-key="aggregates-efficiency">
      <h3>Aggregates (show-efficiency) <span class="unit-badge none" id="unitBadge_pasteAggEfficiency">No data</span></h3>
      <div class="meta">Paste output of: <code class="kbd">storage aggregate show-efficiency -fields …</code></div>
      <textarea class="paste" id="pasteAggEfficiency" spellcheck="false" placeholder="Paste storage aggregate show-efficiency output here…"></textarea>
      <div class="btns">
        <button class="btnExportOne" data-target="pasteAggEfficiency" data-sheet="Aggregates_Efficiency">Export Aggregates_Efficiency.xlsx</button>
      </div>
    </div>

    <div class="section" data-key="volumes">
      <h3>Volumes <span class="unit-badge none" id="unitBadge_pasteVol">No data</span></h3>
      <div class="meta">Paste output of: <code class="kbd">volume show -fields …</code></div>
      <textarea class="paste" id="pasteVol" spellcheck="false" placeholder="Paste volume show output here…"></textarea>
      <div class="btns">
        <button class="btnExportOne" data-target="pasteVol" data-sheet="Volumes">Export Volumes.xlsx</button>
      </div>
    </div>

    <div class="section" data-key="volspace">
      <h3>Volume show-space <span class="unit-badge none" id="unitBadge_pasteVolSpace">No data</span></h3>
      <div class="meta">Paste output of: <code class="kbd">volume show-space -fields …</code></div>
      <textarea class="paste" id="pasteVolSpace" spellcheck="false" placeholder="Paste volume show-space output here…"></textarea>
      <div class="btns">
        <button class="btnExportOne" data-target="pasteVolSpace" data-sheet="Vol_Show_Space">Export Vol_Show_Space.xlsx</button>
      </div>
    </div>

    <div class="section" data-key="snapshots">
      <h3>Snapshots <span class="unit-badge none" id="unitBadge_pasteSnaps">No data</span></h3>
      <div class="meta">Paste output of: <code class="kbd">volume snapshot show -fields …</code></div>
      <textarea class="paste" id="pasteSnaps" spellcheck="false" placeholder="Paste snapshot output here…"></textarea>
      <div class="btns">
        <button class="btnExportOne" data-target="pasteSnaps" data-sheet="Snapshots">Export Snapshots.xlsx</button>
      </div>
    </div>

    <div class="section" data-key="efficiency">
      <h3>Volume efficiency <span class="unit-badge none" id="unitBadge_pasteEff">No data</span></h3>
      <div class="meta">Paste output of: <code class="kbd">volume efficiency show -fields …</code></div>
      <textarea class="paste" id="pasteEff" spellcheck="false" placeholder="Paste efficiency output here…"></textarea>
      <div class="btns">
        <button class="btnExportOne" data-target="pasteEff" data-sheet="Efficiency">Export Efficiency.xlsx</button>
      </div>
    </div>

    <div class="section" data-key="qtrees">
      <h3>Qtrees <span class="unit-badge none" id="unitBadge_pasteQtree">No data</span></h3>
      <div class="meta">Paste output of: <code class="kbd">volume qtree show -fields …</code></div>
      <textarea class="paste" id="pasteQtree" spellcheck="false" placeholder="Paste qtree output here…"></textarea>
      <div class="btns">
        <button class="btnExportOne" data-target="pasteQtree" data-sheet="Qtrees">Export Qtrees.xlsx</button>
      </div>
    </div>

    <div class="section" data-key="luns">
      <h3>LUNs <span class="unit-badge none" id="unitBadge_pasteLun">No data</span></h3>
      <div class="meta">Paste output of: <code class="kbd">lun show -fields …</code></div>
      <textarea class="paste" id="pasteLun" spellcheck="false" placeholder="Paste LUN output here…"></textarea>
      <div class="btns">
        <button class="btnExportOne" data-target="pasteLun" data-sheet="LUNs">Export LUNs.xlsx</button>
      </div>
    </div>

    <div class="section" data-key="cifs">
      <h3>SMB shares <span class="unit-badge none" id="unitBadge_pasteCifs">No data</span></h3>
      <div class="meta">Paste output of: <code class="kbd">vserver cifs share show -fields …</code></div>
      <textarea class="paste" id="pasteCifs" spellcheck="false" placeholder="Paste CIFS share output here…"></textarea>
      <div class="btns">
        <button class="btnExportOne" data-target="pasteCifs" data-sheet="CIFS_Shares">Export CIFS_Shares.xlsx</button>
      </div>
    </div>
  </section>
</div>

<!-- OFFLINE libs (place these files next to this HTML):
     - xlsx.full.min.js  (SheetJS)
     - chart.umd.min.js  (Chart.js)
     - jspdf.umd.min.js  (jsPDF)
     - jspdf.plugin.autotable.min.js  (jsPDF-AutoTable)
-->
<script src="./xlsx.full.min.js"></script>
<script src="./chart.umd.min.js"></script>
<script src="./jspdf.umd.min.js"></script>
<script src="./jspdf.plugin.autotable.min.js"></script>

<script>
  const el = (id) => document.getElementById(id);

  function normDelimiter(v) {
    return v === "\\t" ? "\t" : v;
  }

  function sectionHeader(prefix, title) {
    return `${prefix} ===== ${title} =====`;
  }

  function maybeVserverArg(cmd, svm, scope, isVserverAware) {
    if (!svm) return cmd;
    if (scope === "everywhere") return `${cmd} -vserver ${svm}`;
    return isVserverAware ? `${cmd} -vserver ${svm}` : cmd;
  }

  /* =========================
     Units handling (best-effort)
     ========================= */

  function getUnitsLine() {
    const spec = (el("unitsSpecifier").value || "(none)").trim().toLowerCase();
    const rawChecked = el("unitsRaw").checked;

    if (rawChecked) return "set -units raw";
    if (spec === "(none)") return "";
    return `set -units ${spec}`;
  }

  /* =========================
     Simple local "database"
     - Uses IndexedDB when available
     - Falls back to localStorage
     ========================= */

  const DB = (() => {
    const DB_NAME = "ontap_cli_exporter_db";
    const STORE = "selections";
    const USE_IDB = (() => {
      try { return !!window.indexedDB; } catch { return false; }
    })();

    function lsKey(k) { return `ontap_sel_${k}`; }

    async function idbOpen() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, 1);
        req.onupgradeneeded = () => {
          const db = req.result;
          if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function idbGet(key) {
      const db = await idbOpen();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE, "readonly");
        const store = tx.objectStore(STORE);
        const req = store.get(key);
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function idbSet(key, value) {
      const db = await idbOpen();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE, "readwrite");
        const store = tx.objectStore(STORE);
        const req = store.put(value, key);
        req.onsuccess = () => resolve(true);
        req.onerror = () => reject(req.error);
      });
    }

    async function get(key) {
      if (USE_IDB) {
        try { return await idbGet(key); } catch {}
      }
      try {
        const raw = localStorage.getItem(lsKey(key));
        return raw ? JSON.parse(raw) : undefined;
      } catch {
        return undefined;
      }
    }

    async function set(key, value) {
      if (USE_IDB) {
        try { await idbSet(key, value); return; } catch {}
      }
      try {
        localStorage.setItem(lsKey(key), JSON.stringify(value));
      } catch {}
    }

    async function del(key) {
      if (USE_IDB) {
        try {
          const db = await idbOpen();
          await new Promise((resolve, reject) => {
            const tx = db.transaction(STORE, "readwrite");
            const store = tx.objectStore(STORE);
            const req = store.delete(key);
            req.onsuccess = () => resolve(true);
            req.onerror = () => reject(req.error);
          });
          return;
        } catch {}
      }
      try { localStorage.removeItem(lsKey(key)); } catch {}
    }

    return { get, set, del };
  })();

  function ensureOfflineLibs() {
    const missing = [];
    if (typeof XLSX === "undefined") missing.push("xlsx.full.min.js (SheetJS)");
    if (typeof Chart === "undefined") missing.push("chart.umd.min.js (Chart.js)");
    if (typeof jspdf === "undefined" && typeof jsPDF === "undefined") missing.push("jspdf.umd.min.js (jsPDF)");

    const warn = el("offlineWarn");
    if (missing.length) {
      warn.style.display = "block";
      warn.textContent =
        "Offline libraries missing: " + missing.join(", ") +
        ". Put them in the same folder as this HTML file (no CDN), then refresh.";
      return false;
    }
    warn.style.display = "none";
    warn.textContent = "";
    return true;
  }

  /* =========================
     Field catalogs (from filer)
     ========================= */

  const FIELD_CATALOG = {
    fieldsAggSpace: [
      { f:"aggregate-name", d:"Aggregate" },
      { f:"bin-num", d:"Bin Number" },
      { f:"tier-name", d:"Tier Name For Show Command" },
      { f:"aggregate", d:"Aggregate Display Name" },
      { f:"aggregate-uuid", d:"UUID of the Aggregate" },
      { f:"volume-footprints", d:"Volume Footprints" },
      { f:"volume-footprints-percent", d:"Volume Footprints Percent" },
      { f:"snap-size-total", d:"Total Space for Snapshot Copies in Bytes" },
      { f:"percent-snapshot-space", d:"Space Reserved for Snapshot Copies" },
      { f:"aggregate-metadata", d:"Aggregate Metadata" },
      { f:"aggregate-metadata-percent", d:"Aggregate Metadata Percent" },
      { f:"used-including-snapshot-reserve", d:"Total Used" },
      { f:"used-including-snapshot-reserve-percent", d:"Total Used Percent" },
      { f:"aggregate-size", d:"Size" },
      { f:"snapshot-reserve-unusable", d:"Snapshot Reserve Unusable" },
      { f:"snapshot-reserve-unusable-percent", d:"Snapshot Reserve Unusable Percent" },
      { f:"physical-used", d:"Total Physical Used Size" },
      { f:"physical-used-percent", d:"Physical Used Percentage" },
      { f:"performance-tier-inactive-user-data", d:"Performance Tier Inactive User Data" },
      { f:"performance-tier-inactive-user-data-percent", d:"Performance Tier Inactive User Data Percent" },
      { f:"cross-volume-dedupe-metadata", d:"Aggregate Dedupe Metadata" },
      { f:"cross-volume-dedupe-metadata-percent", d:"Aggregate Dedupe Metadata Percent" },
      { f:"cross-volume-dedupe-temp-metadata", d:"Aggregate Dedupe Temporary Metadata" },
      { f:"cross-volume-dedupe-temp-metadata-percent", d:"Aggregate Dedupe Temporary Metadata Percent" },
      { f:"total-provisioned-space", d:"Total Space Provisioned inside Aggregate" },
      { f:"total-provisioned-space-percent", d:"Percentage Space Provisioned inside Aggregate" },
      { f:"object-store-physical-used", d:"Total Physical Used Size" },
      { f:"object-store-physical-used-percent", d:"Physical Used Percentage" },
      { f:"object-store-referenced-capacity", d:"Total Object Store Logical Referenced Capacity" },
      { f:"object-store-referenced-capacity-percent", d:"Object Store Logical Referenced Capacity Percentage" },
      { f:"object-store-metadata", d:"(DEPRECATED)-Object Store Metadata" },
      { f:"object-store-metadata-percent", d:"(DEPRECATED)-Object Store Metadata Percent" },
      { f:"object-store-unreclaimed-space", d:"(DEPRECATED)-Total Unreclaimed Space" },
      { f:"object-store-unreclaimed-space-percent", d:"(DEPRECATED)-Object Store Unreclaimed Space Percentage" },
      { f:"object-store-size", d:"Object Store Size" },
      { f:"object-store-sis-space-saved", d:"Object Store Space Saved by Storage Efficiency" },
      { f:"object-store-sis-space-saved-percent", d:"Object Store Space Saved by Storage Efficiency Percentage" },
      { f:"object-store-logical-used", d:"Total Logical Used Size" },
      { f:"object-store-logical-used-percent", d:"Logical Used Percentage" },
      { f:"object-store-logical-unreferenced-capacity", d:"Logical Unreferenced Capacity" },
      { f:"object-store-logical-unreferenced-capacity-percent", d:"Logical Unreferenced Percentage" }
    ],
    fieldsAggEfficiency: [
      { f:"aggregate", d:"Name of the Aggregate" },
      { f:"node", d:"Node where Aggregate Resides" },
      { f:"total-storage-efficiency-ratio", d:"Total Storage Efficiency Ratio" },
      { f:"total-data-reduction-efficiency-ratio-wo-snapshots", d:"Total Data Reduction Efficiency Ratio Without Snapshots" },
      { f:"total-data-reduction-efficiency-ratio-wo-snapshots-flexclones", d:"Total Data Reduction Efficiency Ratio Without Snapshots and FlexClones" },
      { f:"volume-logical-used", d:"Logical Space Used for All Volumes" },
      { f:"volume-physical-used", d:"Physical Space Used for All Volumes" },
      { f:"volume-efficiency-saved-ratio", d:"Volume Deduplication Savings Ratio" },
      { f:"volume-compression-saved-ratio", d:"Volume Compression Savings Ratio" },
      { f:"volume-vbn-zero-saved", d:"Space Saved by Inline Zero Pattern Detection" },
      { f:"volume-data-reduction-storage-efficiency-ratio", d:"Volume Data Reduction SE Ratio" },
      { f:"snapshot-volume-data-reduction-storage-efficiency-ratio", d:"Snapshot Volume Data Reduction Ratio" },
      { f:"flexclone-volume-data-reduction-storage-efficiency-ratio", d:"FlexClone Volume Data Reduction Ratio" },
      { f:"snapshot-flexclone-volume-data-reduction-storage-efficiency-ratio", d:"Snapshot and FlexClone Volume Data Reduction SE Ratio" },
      { f:"number-of-offline-volumes", d:"Number of Volumes Offline" },
      { f:"number-of-sis-disabled-volumes", d:"Number of SIS Disabled Volumes" }
    ],
    fieldsQtree: [
      { f:"vserver", d:"Vserver Name" },
      { f:"volume", d:"Volume Name" },
      { f:"qtree", d:"Qtree Name" },
      { f:"qtree-path", d:"Actual (Non-Junction) Qtree Path" },
      { f:"security-style", d:"Security Style" },
      { f:"oplock-mode", d:"Oplock Mode" },
      { f:"user", d:"User ID" },
      { f:"group", d:"Group ID" },
      { f:"unix-permissions", d:"Unix Permissions" },
      { f:"qtree-id", d:"Qtree Id" },
      { f:"status", d:"Qtree Status" },
      { f:"export-policy", d:"Export Policy" },
      { f:"is-export-policy-inherited", d:"Is Export Policy Inherited" },
      { f:"qos-policy-group", d:"QoS policy group" }
    ],
    fieldsLun: [
      { f:"vserver", d:"Vserver Name" },
      { f:"path", d:"LUN Path" },
      { f:"volume", d:"Volume Name" },
      { f:"qtree", d:"Qtree Name" },
      { f:"lun", d:"LUN Name" },
      { f:"size", d:"LUN Size" },
      { f:"ostype", d:"OS Type" },
      { f:"space-reserve", d:"Space Reservation" },
      { f:"serial", d:"Serial Number" },
      { f:"serial-hex", d:"Serial Number (Hex)" },
      { f:"comment", d:"Comment" },
      { f:"space-reserve-honored", d:"Space Reservations Honored" },
      { f:"space-allocation", d:"Space Allocation" },
      { f:"state", d:"State" },
      { f:"uuid", d:"LUN UUID" },
      { f:"mapped", d:"Mapped" },
      { f:"block-size", d:"Physical Size of Logical Block" },
      { f:"device-legacy-id", d:"Device Legacy ID" },
      { f:"device-binary-id", d:"Device Binary ID" },
      { f:"device-text-id", d:"Device Text ID" },
      { f:"read-only", d:"Read Only" },
      { f:"restore-inaccessible", d:"Fenced Due to Restore" },
      { f:"size-used", d:"Used Size" },
      { f:"max-resize-size", d:"Maximum Resize Size" },
      { f:"creation-timestamp", d:"Creation Time" },
      { f:"class", d:"Class" },
      { f:"node", d:"Node Hosting the LUN" },
      { f:"qos-policy-group", d:"QoS Policy Group" },
      { f:"qos-adaptive-policy-group", d:"QoS Adaptive Policy Group" },
      { f:"caching-policy", d:"Caching Policy Name" },
      { f:"is-clone", d:"Clone" },
      { f:"is-clone-autodelete-enabled", d:"Clone Autodelete Enabled" },
      { f:"inconsistent-import", d:"Inconsistent Import" },
      { f:"application", d:"Application" },
      { f:"zrto-vol-consensus", d:"ZRTO Volume consensus" }
    ],
    fieldsCifs: [
      { f:"vserver", d:"Vserver" },
      { f:"share-name", d:"Share" },
      { f:"cifs-server", d:"CIFS Server NetBIOS Name" },
      { f:"path", d:"Path" },
      { f:"share-properties", d:"Share Properties" },
      { f:"symlink-properties", d:"Symlink Properties" },
      { f:"file-umask", d:"File Mode Creation Mask" },
      { f:"dir-umask", d:"Directory Mode Creation Mask" },
      { f:"comment", d:"Share Comment" },
      { f:"acl", d:"Share ACL" },
      { f:"attribute-cache-ttl", d:"File Attribute Cache Lifetime" },
      { f:"volume", d:"Volume Name" },
      { f:"offline-files", d:"Offline Files" },
      { f:"vscan-fileop-profile", d:"Vscan File-Operations Profile" },
      { f:"max-connections-per-share", d:"Maximum Tree Connections on Share" },
      { f:"force-group-for-create", d:"UNIX Group for File Create" }
    ],
    fieldsEff: [
      { f:"vserver", d:"Vserver Name" },
      { f:"volume", d:"Volume Name" },
      { f:"path", d:"Volume Path" },
      { f:"state", d:"State" },
      { f:"op-status", d:"Status" },
      { f:"progress", d:"Progress" },
      { f:"type", d:"Type" },
      { f:"schedule", d:"Schedule" },
      { f:"policy", d:"Efficiency Policy Name" },
      { f:"blks-skipped-sharing", d:"Blocks Skipped Sharing" },
      { f:"last-op-state", d:"Last Operation State" },
      { f:"last-success-op-begin", d:"Last Success Operation Begin" },
      { f:"last-success-op-end", d:"Last Success Operation End" },
      { f:"last-op-begin", d:"Last Operation Begin" },
      { f:"last-op-end", d:"Last Operation End" },
      { f:"last-op-size", d:"Last Operation Size" },
      { f:"last-op-error", d:"Last Operation Error" },
      { f:"changelog-usage", d:"Changelog Usage" },
      { f:"logical-data-size", d:"Logical Data Size" },
      { f:"logical-data-limit", d:"Logical Data Limit" },
      { f:"logical-data-percent", d:"Logical Data Percent" },
      { f:"queued-job", d:"Queued Job" },
      { f:"stale-fingerprint-percentage", d:"Stale Fingerprint Percentage" },
      { f:"compression", d:"Compression" },
      { f:"inline-compression", d:"Inline Compression" },
      { f:"storage-efficiency-mode", d:"Storage Efficiency Mode" },
      { f:"is-constituent", d:"Constituent Volume" },
      { f:"inline-dedupe", d:"Inline Dedupe" },
      { f:"data-compaction", d:"Data Compaction" },
      { f:"cross-volume-inline-dedupe", d:"Cross Volume Inline Deduplication" },
      { f:"cross-volume-background-dedupe", d:"Cross Volume Background Deduplication" },
      { f:"extended-compressed-data", d:"Extended Compressed Data" }
    ],
    fieldsSnaps: [
      { f:"vserver", d:"Vserver" },
      { f:"volume", d:"Volume" },
      { f:"snapshot", d:"Snapshot" },
      { f:"create-time", d:"Creation Time" },
      { f:"busy", d:"Snapshot Busy" },
      { f:"owners", d:"List of Owners" },
      { f:"size", d:"Snapshot Size" },
      { f:"blocks", d:"Percentage of Total Blocks" },
      { f:"usedblocks", d:"Percentage of Used Blocks" },
      { f:"comment", d:"Comment" },
      { f:"is-7-mode", d:"7-Mode Snapshot" },
      { f:"snapmirror-label", d:"Label for SnapMirror Operations" },
      { f:"state", d:"Snapshot State" },
      { f:"is-constituent", d:"Constituent Snapshot" },
      { f:"expiry-time", d:"Expiry Time" },
      { f:"snaplock-expiry-time", d:"SnapLock Expiry Time" }
    ],
    fieldsVolSpace: [
      { f:"vserver", d:"Vserver" },
      { f:"volume", d:"Volume Name" },
      { f:"volume-msid", d:"Volume MSID" },
      { f:"volume-dsid", d:"Volume DSID" },
      { f:"vserver-uuid", d:"Vserver UUID" },
      { f:"aggregate", d:"Aggregate Name" },
      { f:"aggregate-uuid", d:"Aggregate UUID" },
      { f:"hostname", d:"Hostname" },
      { f:"user-data", d:"User Data" },
      { f:"user-data-percent", d:"User Data Percent" },
      { f:"dedupe-metafiles", d:"Deduplication" },
      { f:"dedupe-metafiles-percent", d:"Deduplication Percent" },
      { f:"dedupe-metafiles-temporary", d:"Temporary Deduplication" },
      { f:"dedupe-metafiles-temporary-percent", d:"Temporary Deduplication Percent" },
      { f:"filesystem-metadata", d:"Filesystem Metadata" },
      { f:"filesystem-metadata-percent", d:"Filesystem Metadata Percent" },
      { f:"snapmirror-metadata", d:"SnapMirror Metadata" },
      { f:"snapmirror-metadata-percent", d:"SnapMirror Metadata Percent" },
      { f:"tape-backup-metadata", d:"Tape Backup Metadata" },
      { f:"tape-backup-metadata-percent", d:"Tape Backup Metadata Percent" },
      { f:"quota-metafiles", d:"Quota Metadata" },
      { f:"quota-metafiles-percent", d:"Quota Metadata Percent" },
      { f:"inodes", d:"Inodes" },
      { f:"inodes-percent", d:"Inodes Percent" },
      { f:"inodes-upgrade", d:"Inodes Upgrade" },
      { f:"inodes-upgrade-percent", d:"Inodes Upgrade Percent" },
      { f:"snapshot-reserve", d:"Snapshot Reserve" },
      { f:"snapshot-reserve-percent", d:"Snapshot Reserve Percent" },
      { f:"snapshot-reserve-unusable", d:"Snapshot Reserve Unusable" },
      { f:"snapshot-reserve-unusable-percent", d:"Snapshot Reserve Unusable Percent" },
      { f:"snapshot-spill", d:"Snapshot Spill" },
      { f:"snapshot-spill-percent", d:"Snapshot Spill Percent" },
      { f:"performance-metadata", d:"Performance Metadata" },
      { f:"performance-metadata-percent", d:"Performance Metadata Percent" },
      { f:"total-used", d:"Total Used" },
      { f:"total-used-percent", d:"Total Used Percent" },
      { f:"physical-used", d:"Total Physical Used Size" },
      { f:"physical-used-percent", d:"Physical Used Percentage" },
      { f:"logical-used", d:"Logical Used Size" },
      { f:"logical-used-percent", d:"Logical Used Percent" },
      { f:"logical-available", d:"Logical Available" }
    ],
    fieldsVol: [
      { f:"vserver", d:"Vserver Name" },
      { f:"volume", d:"Volume Name" },
      { f:"aggregate", d:"Aggregate Name" },
      { f:"aggr-list", d:"List of Aggregates for FlexGroup Constituents" },
      { f:"encryption-type", d:"Encryption Type" },
      { f:"nodes", d:"List of Nodes Hosting the Volume" },
      { f:"size", d:"Volume Size" },
      { f:"dsid", d:"Volume Data Set ID" },
      { f:"msid", d:"Volume Master Data Set ID" },
      { f:"state", d:"Volume State" },
      { f:"volume-style", d:"Volume Style" },
      { f:"volume-style-extended", d:"Extended Volume Style" },
      { f:"flexcache-endpoint-type", d:"FlexCache Endpoint Type" },
      { f:"is-cluster-volume", d:"Is Cluster-Mode Volume" },
      { f:"is-constituent", d:"Is Constituent Volume" },
      { f:"constituent-count", d:"Number of Constituent Volumes" },
      { f:"policy", d:"Export Policy" },
      { f:"user", d:"User ID" },
      { f:"group", d:"Group ID" },
      { f:"security-style", d:"Security Style" },
      { f:"unix-permissions", d:"UNIX Permissions" },
      { f:"junction-path", d:"Junction Path" },
      { f:"junction-path-source", d:"Junction Path Source" },
      { f:"junction-active", d:"Junction Active" },
      { f:"junction-parent", d:"Junction Parent Volume" },
      { f:"comment", d:"Comment" },
      { f:"available", d:"Available Size" },
      { f:"filesystem-size", d:"Filesystem Size" },
      { f:"total", d:"Total User-Visible Size" },
      { f:"used", d:"Used Size" },
      { f:"percent-used", d:"Used Percentage" },
      { f:"space-nearly-full-threshold-percent", d:"Volume Nearly Full Threshold Percent" },
      { f:"space-full-threshold-percent", d:"Volume Full Threshold Percent" },
      { f:"max-autosize", d:"Maximum Autosize" },
      { f:"min-autosize", d:"Minimum Autosize" },
      { f:"autosize-grow-threshold-percent", d:"Autosize Grow Threshold Percentage" },
      { f:"autosize-shrink-threshold-percent", d:"Autosize Shrink Threshold Percentage" },
      { f:"autosize-mode", d:"Autosize Mode" },
      { f:"files", d:"Total Files (for user-visible data)" },
      { f:"files-used", d:"Files Used (for user-visible data)" },
      { f:"space-guarantee-enabled", d:"Space Guarantee in Effect" },
      { f:"is-space-slo-enabled", d:"Space SLO in Effect" },
      { f:"space-slo", d:"Space SLO" },
      { f:"space-guarantee", d:"Space Guarantee Style" },
      { f:"fractional-reserve", d:"Fractional Reserve" },
      { f:"type", d:"Volume Type" },
      { f:"snapdir-access", d:"Snapshot Directory Access Enabled" },
      { f:"percent-snapshot-space", d:"Space Reserved for Snapshot Copies" },
      { f:"snapshot-space-used", d:"Snapshot Reserve Used" },
      { f:"snapshot-policy", d:"Snapshot Policy" },
      { f:"create-time", d:"Creation Time" },
      { f:"language", d:"Language" },
      { f:"clone-volume", d:"Clone Volume" },
      { f:"node", d:"Node name" },
      { f:"clone-parent-vserver", d:"Clone Parent Vserver Name" },
      { f:"clone-parent-name", d:"FlexClone Parent Volume" },
      { f:"nvfail", d:"NVFAIL Option" },
      { f:"in-nvfailed-state", d:"Volume's NVFAIL State" },
      { f:"dr-force-nvfail", d:"Force NVFAIL on MetroCluster Switchover" },
      { f:"filesys-size-fixed", d:"Is File System Size Fixed" },
      { f:"extent-enabled", d:"(DEPRECATED)-Extent Option" },
      { f:"overwrite-reserve", d:"Reserved Space for Overwrites" },
      { f:"space-mgmt-try-first", d:"Primary Space Management Strategy" },
      { f:"read-realloc", d:"Read Reallocation Option" },
      { f:"sched-snap-name", d:"Naming Scheme for Automatic Snapshot Copies" },
      { f:"is-inconsistent", d:"Inconsistency in the File System" },
      { f:"is-quiesced-on-disk", d:"Is Volume Quiesced (On-Disk)" },
      { f:"is-quiesced-in-memory", d:"Is Volume Quiesced (In-Memory)" },
      { f:"is-sis-volume", d:"Volume Contains Shared or Compressed Data" },
      { f:"sis-space-saved", d:"Space Saved by Storage Efficiency" },
      { f:"sis-space-saved-percent", d:"Percentage Saved by Storage Efficiency" },
      { f:"dedupe-space-saved", d:"Space Saved by Deduplication" },
      { f:"dedupe-space-saved-percent", d:"Percentage Saved by Deduplication" },
      { f:"dedupe-space-shared", d:"Space Shared by Deduplication" },
      { f:"compression-space-saved", d:"Space Saved by Compression" },
      { f:"compression-space-saved-percent", d:"Percentage Space Saved by Compression" },
      { f:"size-used-by-snapshots", d:"Volume Size Used by Snapshot Copies" },
      { f:"block-type", d:"Block Type" },
      { f:"is-moving", d:"Is Volume Moving" },
      { f:"hybrid-cache-eligibility", d:"Flash Pool Caching Eligibility" },
      { f:"hybrid-cache-write-caching-ineligibility-reason", d:"Flash Pool Write Caching Ineligibility Reason" },
      { f:"constituent-role", d:"Constituent Volume Role" },
      { f:"qos-policy-group", d:"QoS Policy Group Name" },
      { f:"qos-adaptive-policy-group", d:"QoS Adaptive Policy Group Name" },
      { f:"caching-policy", d:"Caching Policy Name" },
      { f:"is-volume-in-cutover", d:"Is Volume Move in Cutover Phase" },
      { f:"snapshot-count", d:"Number of Snapshot Copies in the Volume" },
      { f:"vbn-bad-present", d:"VBN_BAD may be present in the active filesystem" },
      { f:"is-vol-on-hybrid-aggr", d:"Is Volume on a hybrid aggregate" },
      { f:"physical-used", d:"Total Physical Used Size" },
      { f:"physical-used-percent", d:"Physical Used Percentage" },
      { f:"flexgroup-name", d:"FlexGroup Name" },
      { f:"is-flexgroup", d:"Is Volume a FlexGroup" },
      { f:"snaplock-type", d:"SnapLock Type" },
      { f:"vserver-dr-protection", d:"Vserver DR Protection" },
      { f:"encrypt", d:"Enable or Disable Encryption" },
      { f:"is-encrypted", d:"Is Volume Encrypted" },
      { f:"encryption-state", d:"Encryption State" },
      { f:"key-id", d:"Encryption Key ID" },
      { f:"key-creation-time", d:"Encryption Key Creation Time" },
      { f:"application", d:"Application" },
      { f:"is-protocol-access-fenced", d:"Is Fenced for Protocol Access" },
      { f:"protocol-access-fenced-by", d:"Protocol Access Fence Owner" },
      { f:"single-instance-data-logging", d:"Is SIDL enabled" },
      { f:"over-provisioned", d:"Over Provisioned Size" },
      { f:"snapshot-reserve-available", d:"Available Snapshot Reserve Size" },
      { f:"logical-used", d:"Logical Used Size" },
      { f:"logical-used-percent", d:"Logical Used Percentage" },
      { f:"logical-available", d:"Logical Available Size" },
      { f:"logical-used-by-afs", d:"Logical Size Used by Active Filesystem" },
      { f:"logical-used-by-snapshots", d:"Logical Size Used by All Snapshots" },
      { f:"is-space-reporting-logical", d:"Logical Space Reporting" },
      { f:"is-space-enforcement-logical", d:"Logical Space Enforcement" },
      { f:"tiering-policy", d:"Volume Tiering Policy" },
      { f:"performance-tier-inactive-user-data", d:"Performance Tier Inactive User Data" },
      { f:"performance-tier-inactive-user-data-percent", d:"Performance Tier Inactive User Data Percent" },
      { f:"tiering-object-tags", d:"Tags to be Associated with Objects Stored on a FabricPool" },
      { f:"needs-object-retagging", d:"Does the Object Tagging Scanner Need to Run on This Volume" },
      { f:"is-analytics-supported", d:"Is File System Analytics Supported" },
      { f:"analytics-unsupported-reason", d:"Reason File System Analytics is not Supported" },
      { f:"analytics-state", d:"File System Analytics State" },
      { f:"analytics-scan-progress", d:"File System Analytics Scan Progress" },
      { f:"activity-tracking-state", d:"Activity Tracking State" },
      { f:"is-activity-tracking-supported", d:"Is Activity Tracking Supported" },
      { f:"activity-tracking-unsupported-reason", d:"Reason Activity Tracking Is Not Supported" },
      { f:"is-smbc-master", d:"Is SMBC Master" },
      { f:"is-smbc-failover-capable", d:"Is SMBC Failover Capable" },
      { f:"smbc-consensus", d:"SMBC Consensus" },
      { f:"anti-ransomware-state", d:"Anti-ransomware State" }
    ]
  };

  /* =========================
     Field picker rendering
     ========================= */

  function parseFieldList(str) {
    return (str || "")
      .split(",")
      .map(s => s.trim())
      .filter(Boolean);
  }

  function uniq(arr) {
    const seen = new Set();
    const out = [];
    for (const x of arr) {
      if (!seen.has(x)) { seen.add(x); out.push(x); }
    }
    return out;
  }

  function setInputFields(inputId, fields) {
    const cleaned = uniq(fields).join(",");
    el(inputId).value = cleaned;
  }

  function getSelectedFromInput(inputId, catalog) {
    const raw = parseFieldList(el(inputId).value);
    if (!raw.length) return [];
    const valid = new Set((catalog || []).map(x => x.f));
    return raw.filter(f => valid.has(f));
  }

  function debounce(fn, ms) {
    let t = null;
    return (...args) => {
      clearTimeout(t);
      t = setTimeout(() => fn(...args), ms);
    };
  }

  const regenDebounced = debounce(() => genPuttyBlock(), 80);

  function renderPicker(inputId, title) {
    const host = el(`picker_${inputId}`);
    const catalog = FIELD_CATALOG[inputId] || [];
    const pillId = `${inputId}_count`;

    host.innerHTML = `
      <details class="picker">
        <summary>
          <span>${title} field picker</span>
          <span class="pill" id="${pillId}">0 selected</span>
        </summary>
        <div class="pickerBody">
          <div class="pickerTools">
            <input type="text" id="${inputId}_search" placeholder="Search fields…" />
            <button class="secondary" id="${inputId}_all">All</button>
            <button class="secondary" id="${inputId}_none">None</button>
          </div>
          <div class="pickerList" id="${inputId}_list"></div>
          <div class="tiny" style="margin-top:8px;">
            Tip: You can also edit the comma-separated list above; the tick boxes will sync on blur.
          </div>
        </div>
      </details>
    `;

    const listEl = el(`${inputId}_list`);
    const searchEl = el(`${inputId}_search`);

    function makeRow(item) {
      const row = document.createElement("div");
      row.className = "pickItem";
      row.dataset.field = item.f;
      row.dataset.desc = (item.d || "").toLowerCase();
      row.dataset.f = item.f.toLowerCase();
      row.innerHTML = `
        <input type="checkbox" />
        <div>
          <div class="pickField">${item.f}</div>
          <div class="pickDesc">${item.d || ""}</div>
        </div>
      `;
      return row;
    }

    for (const item of catalog) listEl.appendChild(makeRow(item));

    function updatePill() {
      const checked = listEl.querySelectorAll('input[type="checkbox"]:checked').length;
      el(pillId).textContent = `${checked} selected`;
    }

    function getCheckedFields() {
      const rows = Array.from(listEl.querySelectorAll(".pickItem"));
      return rows
        .filter(r => r.querySelector('input[type="checkbox"]').checked)
        .map(r => r.dataset.field);
    }

    function applyToInputAndSave() {
      const selected = getCheckedFields();
      setInputFields(inputId, selected);
      DB.set(inputId, selected);
      regenDebounced();
      updatePill();
    }

    function setAll(checked) {
      listEl.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = checked);
      applyToInputAndSave();
    }

    function syncCheckboxesFromInput() {
      const selected = new Set(getSelectedFromInput(inputId, catalog));
      listEl.querySelectorAll(".pickItem").forEach(row => {
        row.querySelector('input[type="checkbox"]').checked = selected.has(row.dataset.field);
      });
      DB.set(inputId, Array.from(selected));
      regenDebounced();
      updatePill();
    }

    listEl.addEventListener("change", (e) => {
      if (e.target && e.target.matches('input[type="checkbox"]')) applyToInputAndSave();
    });

    searchEl.addEventListener("input", () => {
      const q = (searchEl.value || "").trim().toLowerCase();
      listEl.querySelectorAll(".pickItem").forEach(row => {
        const hit = !q || row.dataset.f.includes(q) || row.dataset.desc.includes(q);
        row.style.display = hit ? "" : "none";
      });
    });

    el(`${inputId}_all`).addEventListener("click", () => setAll(true));
    el(`${inputId}_none`).addEventListener("click", () => setAll(false));

    el(inputId).addEventListener("blur", syncCheckboxesFromInput);

    return {
      setCheckedFromList: (fields) => {
        const selected = new Set(fields || []);
        listEl.querySelectorAll(".pickItem").forEach(row => {
          row.querySelector('input[type="checkbox"]').checked = selected.has(row.dataset.field);
        });
        setInputFields(inputId, Array.from(selected));
        updatePill();
      }
    };
  }

  /* =========================
     PuTTY block generation
     ========================= */

  function genPuttyBlock() {
    const delim = normDelimiter(el("delimiter").value);
    const prefix = el("commentPrefix").value;
    const svm = el("svm").value.trim();
    const scope = el("scope").value;

    const lines = [];
    lines.push(sectionHeader(prefix, "SESSION DISPLAY SETTINGS"));
    if (el("showAllFields").checked) lines.push(`set -showallfields true`);
    lines.push(`set -showseparator "${delim === "\t" ? "\\t" : delim}"`);

    const unitsLine = getUnitsLine();
    if (unitsLine) lines.push(unitsLine);

    if (el("rows0").checked) lines.push(`rows 0`);
    lines.push("");

    lines.push(sectionHeader(prefix, "AGGREGATES / LOCAL TIERS"));
    {
      const fieldsSpace = el("fieldsAggSpace").value.trim();
      const fieldsEfficiency = el("fieldsAggEfficiency").value.trim();
      
      lines.push(fieldsSpace ? `storage aggregate show-space -fields ${fieldsSpace}` : `storage aggregate show-space`);
      lines.push(fieldsEfficiency ? `storage aggregate show-efficiency -fields ${fieldsEfficiency}` : `storage aggregate show-efficiency`);
    }
    lines.push("");

    lines.push(sectionHeader(prefix, "VOLUMES (INVENTORY)"));
    {
      const fields = el("fieldsVol").value.trim();
      let cmd = fields ? `volume show -fields ${fields}` : `volume show`;
      cmd = maybeVserverArg(cmd, svm, scope, true);
      lines.push(cmd);
    }
    lines.push("");

    lines.push(sectionHeader(prefix, "VOLUME SPACE (SHOW-SPACE)"));
    {
      const fields = el("fieldsVolSpace").value.trim();
      let cmd = fields ? `volume show-space -fields ${fields}` : `volume show-space`;
      cmd = maybeVserverArg(cmd, svm, scope, true);
      lines.push(cmd);
    }
    lines.push("");

    lines.push(sectionHeader(prefix, "SNAPSHOTS"));
    {
      const fields = el("fieldsSnaps").value.trim();
      let cmd = fields ? `volume snapshot show -fields ${fields}` : `volume snapshot show`;
      cmd = maybeVserverArg(cmd, svm, scope, true);
      lines.push(cmd);
    }
    lines.push("");

    lines.push(sectionHeader(prefix, "VOLUME EFFICIENCY"));
    {
      const fields = el("fieldsEff").value.trim();
      let cmd = fields ? `volume efficiency show -fields ${fields}` : `volume efficiency show`;
      cmd = maybeVserverArg(cmd, svm, scope, true);
      lines.push(cmd);
    }
    lines.push("");

    lines.push(sectionHeader(prefix, "QTREES"));
    {
      const fields = el("fieldsQtree").value.trim();
      let cmd = fields ? `volume qtree show -fields ${fields}` : `volume qtree show`;
      cmd = maybeVserverArg(cmd, svm, scope, true);
      lines.push(cmd);
    }
    lines.push("");

    lines.push(sectionHeader(prefix, "LUNS"));
    {
      const fields = el("fieldsLun").value.trim();
      let cmd = fields ? `lun show -fields ${fields}` : `lun show`;
      cmd = maybeVserverArg(cmd, svm, scope, true);
      lines.push(cmd);
    }
    lines.push("");

    lines.push(sectionHeader(prefix, "CIFS SHARES"));
    {
      const fields = el("fieldsCifs").value.trim();
      let cmd = fields ? `vserver cifs share show -fields ${fields}` : `vserver cifs share show`;
      cmd = maybeVserverArg(cmd, svm, scope, true);
      lines.push(cmd);
    }
    lines.push("");

    lines.push(sectionHeader(prefix, "FIELD DISCOVERY (REFERENCE)"));
    lines.push(`${prefix} storage aggregate show -fields ?`);
    lines.push(`${prefix} volume show -fields ?`);
    lines.push(`${prefix} volume show-space -fields ?`);
    lines.push(`${prefix} volume snapshot show -fields ?`);
    lines.push(`${prefix} volume efficiency show -fields ?`);
    lines.push(`${prefix} volume qtree show -fields ?`);
    lines.push(`${prefix} lun show -fields ?`);
    lines.push(`${prefix} vserver cifs share show -fields ?`);

    el("out").value = lines.join("\n");
  }

  // --- Parsing delimited text into AOAs (array-of-arrays) ---
  function parseDelimited(text, delimiter) {
    const lines = (text || "")
      .split(/\r?\n/)
      .map(l => l.trimEnd())
      .filter(l => l.trim().length > 0)
      .filter(l => !l.trimStart().startsWith("#"));

    const rows = [];
    for (const line of lines) {
      const cols = line.split(delimiter).map(c => c.trim());
      rows.push(cols);
    }
    return rows;
  }

  function toSafeSheetName(name) {
    const cleaned = name.replace(/[:\\\/\?\*\[\]]/g, "_").slice(0, 31);
    return cleaned.length ? cleaned : "Sheet1";
  }

  /* =========================
     XLSX export processing:
     - Strip MB/GB/TB suffix from size fields (keep numeric)
     - Put unit in the header
     - Add totals row for size columns
     ========================= */

  function looksLikeSizeHeader(h) {
    const s = String(h || "").toLowerCase();
    // Heuristic: wide net for ONTAP "size-like" fields
    return /(^|[-_])(size|used|available|total|reserve|spill|data|metafiles|physical|logical|max|min|filesystem|overwrite|over-provisioned|snapshot)([-_]|$)/.test(s)
      || /(physical|logical|snapshot)/.test(s)
      || s === "size"
      || s.endsWith("used")
      || s.endsWith("available")
      || s.endsWith("total");
  }

  function parseSizeValue(v) {
    // returns { num: number|null, unit: "KB"|"MB"|"GB"|"TB"|"PB"|null }
    if (v == null) return { num: null, unit: null };
    let s = String(v).trim();
    if (!s) return { num: null, unit: null };

    // ignore percents
    if (s.endsWith("%")) return { num: null, unit: null };

    // remove commas
    s = s.replace(/,/g, "");

    // strict size suffixes
    const m = s.match(/^(-?\d+(?:\.\d+)?)(?:\s*(KB|MB|GB|TB|PB))?$/i);
    if (!m) return { num: null, unit: null };
    const num = parseFloat(m[1]);
    if (!Number.isFinite(num)) return { num: null, unit: null };
    const unit = m[2] ? m[2].toUpperCase() : null;
    return { num, unit };
  }

  function unitToBytesMult(unit) {
    const u = (unit || "").toUpperCase();
    return u === "KB" ? 1024 :
           u === "MB" ? 1024 ** 2 :
           u === "GB" ? 1024 ** 3 :
           u === "TB" ? 1024 ** 4 :
           u === "PB" ? 1024 ** 5 : 1;
  }

  function headerWithUnit(h, unitTag) {
    const base = String(h || "").trim();
    if (!unitTag) return base;
    const tag = String(unitTag).trim();
    if (!tag) return base;
    // avoid double-tagging
    if (base.toLowerCase().includes(`(${tag.toLowerCase()})`)) return base;
    return `${base} (${tag})`;
  }

  function transformAoaForXlsx(aoa, fromUnit = "none", toUnit = "none") {
    // returns { aoa, meta:{ sizeCols:[{idx, unitTag}]} }
    if (!Array.isArray(aoa) || aoa.length === 0) return { aoa, meta: { sizeCols: [] } };

    const headers = (aoa[0] || []).map(h => String(h ?? "").trim());
    const dataRows = aoa.slice(1);

    const sizeCols = [];

    for (let c = 0; c < headers.length; c++) {
      const h = headers[c];
      const headerSuggests = looksLikeSizeHeader(h);

      // scan values for unit suffix
      let unitSet = new Set();
      let parsedCount = 0;
      let nonEmptyCount = 0;

      for (const r of dataRows) {
        const v = r[c];
        if (v == null || String(v).trim() === "") continue;
        nonEmptyCount++;

        const p = parseSizeValue(v);
        if (p.num == null) continue;
        parsedCount++;
        if (p.unit) unitSet.add(p.unit);
      }

      // decide if size column
      // - strong if header suggests AND at least some numeric parses
      // - or if many values parse with units
      const unitLike = unitSet.size > 0;
      const parseRatio = nonEmptyCount ? (parsedCount / nonEmptyCount) : 0;
      const isSize = (headerSuggests && parsedCount > 0) || (unitLike && parseRatio >= 0.5);

      if (!isSize) continue;

      // determine unit strategy:
      // - single unit: keep numeric in that unit, header shows unit (GB/TB/MB...)
      // - multiple units: convert to bytes, header shows bytes
      // - no units found: treat as raw
      let unitTag = "raw";
      let mode = "raw"; // "raw" | "single" | "bytes"
      let singleUnit = null;

      if (unitSet.size === 1) {
        singleUnit = Array.from(unitSet)[0];
        unitTag = singleUnit;
        mode = "single";
      } else if (unitSet.size > 1) {
        unitTag = "bytes";
        mode = "bytes";
      } else {
        unitTag = "raw";
        mode = "raw";
      }

      sizeCols.push({ idx: c, unitTag, mode, singleUnit });
    }

    if (!sizeCols.length) return { aoa, meta: { sizeCols: [] } };

    // clone to avoid mutating original reference
    const out = aoa.map(r => r.slice());

    // update headers with unit tags
    for (const sc of sizeCols) {
      // If user requested conversion, use that unit in the header
      const finalUnitTag = (fromUnit !== "none" && toUnit !== "none") ? toUnit : sc.unitTag;
      out[0][sc.idx] = headerWithUnit(headers[sc.idx], finalUnitTag);
    }

    // convert values
    for (let r = 1; r < out.length; r++) {
      for (const sc of sizeCols) {
        const v = out[r][sc.idx];
        const p = parseSizeValue(v);
        if (p.num == null) {
          // If it's empty or unparseable, leave as-is
          continue;
        }

        let finalValue;
        let actualSourceUnit; // Track the actual unit of the value after parsing

        if (sc.mode === "single") {
          // If value has a different unit (unexpected), convert to the header unit to keep column consistent
          if (p.unit && p.unit !== sc.singleUnit) {
            const bytes = p.num * unitToBytesMult(p.unit);
            const numInUnit = bytes / unitToBytesMult(sc.singleUnit);
            finalValue = numInUnit;
            actualSourceUnit = sc.singleUnit;
          } else if (p.unit) {
            // Value has unit suffix matching the single unit
            finalValue = p.num;
            actualSourceUnit = sc.singleUnit;
          } else {
            // Plain number, no unit suffix
            finalValue = p.num;
            actualSourceUnit = null; // Will use fromUnit
          }
        } else if (sc.mode === "bytes") {
          // Convert to bytes
          const bytes = p.num * (p.unit ? unitToBytesMult(p.unit) : 1);
          finalValue = bytes;
          actualSourceUnit = p.unit ? "raw" : null; // If had unit, now in bytes; else needs fromUnit
        } else {
          // raw: strip any unit if present, otherwise keep number
          if (p.unit) {
            // Value had a unit suffix - convert to bytes
            finalValue = p.num * unitToBytesMult(p.unit);
            actualSourceUnit = "raw";
          } else {
            // Plain number
            finalValue = p.num;
            actualSourceUnit = null; // Will use fromUnit
          }
        }

        // Apply user-requested unit conversion
        if (fromUnit !== "none" && toUnit !== "none") {
          // Determine the source unit for conversion
          let sourceUnit;
          if (actualSourceUnit !== null) {
            // Value had a unit suffix, already converted
            sourceUnit = actualSourceUnit;
          } else {
            // Plain number - use user-specified fromUnit
            sourceUnit = fromUnit;
          }
          // Apply conversion
          finalValue = convertUnit(finalValue, sourceUnit, toUnit);
        }

        out[r][sc.idx] = finalValue;
      }
    }

    // totals row
    const totals = new Array(headers.length).fill("");
    totals[0] = "TOTAL";

    for (const sc of sizeCols) {
      let sum = 0;
      let saw = false;
      for (let r = 1; r < out.length; r++) {
        const v = out[r][sc.idx];
        const num = typeof v === "number" ? v : parseFloat(String(v).replace(/,/g, ""));
        if (Number.isFinite(num)) {
          sum += num;
          saw = true;
        }
      }
      if (saw) totals[sc.idx] = sum;
    }

    out.push(totals);

    return { aoa: out, meta: { sizeCols } };
  }

  function exportOne(textareaId, sheetName, filenameBase) {
    if (!ensureOfflineLibs()) {
      alert("Missing offline library: XLSX. Put xlsx.full.min.js next to this HTML and refresh.");
      return;
    }
    const delimiter = normDelimiter(el("delimiter").value);
    const text = el(textareaId).value;

    const aoaRaw = parseDelimited(text, delimiter);
    if (!aoaRaw.length) {
      alert("Nothing to export — paste or import some delimited output first.");
      return;
    }

    // Get unit conversion settings
    const fromUnit = el("xlsxUnitFrom").value;
    const toUnit = el("xlsxUnitTo").value;

    const { aoa } = transformAoaForXlsx(aoaRaw, fromUnit, toUnit);

    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.aoa_to_sheet(aoa);
    XLSX.utils.book_append_sheet(wb, ws, toSafeSheetName(sheetName));

    XLSX.writeFile(wb, `${filenameBase}.xlsx`);
  }

  function exportAll() {
    if (!ensureOfflineLibs()) {
      alert("Missing offline library: XLSX. Put xlsx.full.min.js next to this HTML and refresh.");
      return;
    }
    const delimiter = normDelimiter(el("delimiter").value);

    // Get unit conversion settings
    const fromUnit = el("xlsxUnitFrom").value;
    const toUnit = el("xlsxUnitTo").value;

    const sources = [
      { id: "pasteAggSpace",     sheet: "Aggregates_Space" },
      { id: "pasteAggEfficiency", sheet: "Aggregates_Efficiency" },
      { id: "pasteVol",      sheet: "Volumes" },
      { id: "pasteVolSpace", sheet: "Vol_Show_Space" },
      { id: "pasteSnaps",    sheet: "Snapshots" },
      { id: "pasteEff",      sheet: "Efficiency" },
      { id: "pasteQtree",    sheet: "Qtrees" },
      { id: "pasteLun",      sheet: "LUNs" },
      { id: "pasteCifs",     sheet: "CIFS_Shares" }
    ];

    const wb = XLSX.utils.book_new();
    let added = 0;

    for (const s of sources) {
      const txt = el(s.id).value;
      const aoaRaw = parseDelimited(txt, delimiter);
      if (!aoaRaw.length) continue;

      const { aoa } = transformAoaForXlsx(aoaRaw, fromUnit, toUnit);

      const ws = XLSX.utils.aoa_to_sheet(aoa);
      XLSX.utils.book_append_sheet(wb, ws, toSafeSheetName(s.sheet));
      added++;
    }

    if (!added) {
      alert("Nothing to export — paste or import at least one section’s output first.");
      return;
    }

    const stamp = new Date().toISOString().replace(/[:.]/g,"-").slice(0,19);
    XLSX.writeFile(wb, `ontap_export_${stamp}.xlsx`);
  }

  function generatePDFReport() {
    // Check if jsPDF is available
    const jsPDFLib = window.jspdf?.jsPDF || window.jsPDF;
    if (!jsPDFLib) {
      alert("jsPDF library not found. Please download jspdf.umd.min.js and place it in the same folder as this HTML file.\n\nDownload from: https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js");
      return;
    }
    
    try {
      const doc = new jsPDFLib();
    const pageWidth = doc.internal.pageSize.getWidth();
    const margin = 14;
    let yPos = 20;
    
    // Helper function to add section header
    function addSectionHeader(title) {
      if (yPos > 260) {
        doc.addPage();
        yPos = 20;
      }
      doc.setFontSize(14);
      doc.setFont(undefined, 'bold');
      doc.text(title, margin, yPos);
      yPos += 8;
      doc.setFont(undefined, 'normal');
      doc.setFontSize(10);
    }
    
    // Helper function to add key-value line
    function addLine(label, value) {
      if (yPos > 275) {
        doc.addPage();
        yPos = 20;
      }
      doc.text(`${label}: ${value}`, margin, yPos);
      yPos += 6;
    }
    
    // Helper function to add description line (italic, smaller font, gray)
    function addDescription(text) {
      if (yPos > 275) {
        doc.addPage();
        yPos = 20;
      }
      doc.setFontSize(9);
      doc.setFont(undefined, 'italic');
      doc.setTextColor(100, 100, 100);
      doc.text(text, margin + 2, yPos);
      yPos += 5;
      doc.setFont(undefined, 'normal');
      doc.setFontSize(10);
      doc.setTextColor(0, 0, 0);
    }
    
    // Helper function to add line with description
    function addLineWithDesc(label, value, description) {
      addLine(label, value);
      if (description) {
        addDescription(description);
      }
    }
    
    // Helper function to create and embed a chart
    function addChart(chartConfig, width = 160, height = 100) {
      if (typeof Chart === 'undefined') {
        console.warn("Chart.js not available, skipping chart");
        return;
      }
      
      try {
        // Create an offscreen canvas
        const canvas = document.createElement('canvas');
        canvas.width = width * 2; // Higher resolution
        canvas.height = height * 2;
        const ctx = canvas.getContext('2d');
        
        // Create chart
        const chart = new Chart(ctx, chartConfig);
        
        // Convert to image and add to PDF
        const imgData = canvas.toDataURL('image/png');
        
        // Check if we need a new page
        if (yPos + height > 280) {
          doc.addPage();
          yPos = 20;
        }
        
        doc.addImage(imgData, 'PNG', margin, yPos, width, height);
        yPos += height + 8;
        
        // Cleanup
        chart.destroy();
      } catch (error) {
        console.error("Error creating chart:", error);
      }
    }
    
    // Helper function to add a callout box
    function addCallout(title, text) {
      if (yPos > 260) {
        doc.addPage();
        yPos = 20;
      }
      
      // Draw background box
      doc.setFillColor(240, 248, 255);
      doc.setDrawColor(70, 130, 180);
      doc.rect(margin, yPos - 4, pageWidth - 2 * margin, 18, 'FD');
      
      // Add title with icon
      doc.setFontSize(10);
      doc.setFont(undefined, 'bold');
      doc.setTextColor(70, 130, 180);
      doc.text(`📊 ${title}`, margin + 2, yPos + 2);
      yPos += 8;
      
      // Add text
      doc.setFont(undefined, 'normal');
      doc.setFontSize(9);
      doc.setTextColor(0, 0, 0);
      const lines = doc.splitTextToSize(text, pageWidth - 2 * margin - 4);
      doc.text(lines, margin + 2, yPos);
      yPos += lines.length * 4 + 8;
      
      doc.setTextColor(0, 0, 0);
    }
    
    // Helper to parse pasted data
    function parseData(textareaId) {
      const textarea = el(textareaId);
      if (!textarea) return { headers: [], rows: [] };
      
      const text = textarea.value.trim();
      if (!text) return { headers: [], rows: [] };
      
      const delimiter = normDelimiter(el("delimiter").value);
      const lines = text.split(/\r?\n/).filter(line => {
        const trimmed = line.trim();
        return trimmed && !trimmed.startsWith("#");
      });
      
      if (lines.length === 0) return { headers: [], rows: [] };
      
      const headers = lines[0].split(delimiter).map(h => h.trim());
      const rows = lines.slice(1).map(line => line.split(delimiter).map(c => c.trim()));
      
      return { headers, rows };
    }
    
    // Helper to find column index with priority-based matching
    function findCol(headers, ...names) {
      // Priority 1: Try exact match for all names first
      for (const name of names) {
        const idx = headers.findIndex(h => h.toLowerCase() === name.toLowerCase());
        if (idx !== -1) return idx;
      }
      
      // Priority 2: Try starts-with match for all names
      for (const name of names) {
        const idx = headers.findIndex(h => h.toLowerCase().startsWith(name.toLowerCase()));
        if (idx !== -1) return idx;
      }
      
      // Priority 3: Try contains match for all names (original behavior)
      for (const name of names) {
        const idx = headers.findIndex(h => h.toLowerCase().includes(name.toLowerCase()));
        if (idx !== -1) return idx;
      }
      
      return -1;
    }
    
    // Helper to find column by exact name match (case-insensitive)
    function findExactCol(headers, exactName) {
      return headers.findIndex(h => h.trim().toLowerCase() === exactName.trim().toLowerCase());
    }
    
    // Helper to find column using FIELD_CATALOG to try both field name and friendly name
    function findColWithCatalog(headers, fieldName, catalogKey) {
      // Get friendly name from catalog if available
      let friendlyName = null;
      if (catalogKey && FIELD_CATALOG[catalogKey]) {
        const catalogEntry = FIELD_CATALOG[catalogKey].find(entry => entry.f === fieldName);
        if (catalogEntry && catalogEntry.d) {
          friendlyName = catalogEntry.d;
        }
      }
      
      // Priority 1: Try exact match for field name
      let idx = headers.findIndex(h => h.toLowerCase() === fieldName.toLowerCase());
      if (idx !== -1) return idx;
      
      // Priority 2: Try exact match for friendly name
      if (friendlyName) {
        idx = headers.findIndex(h => h.toLowerCase() === friendlyName.toLowerCase());
        if (idx !== -1) return idx;
      }
      
      // Priority 3: Try starts-with match for field name
      idx = headers.findIndex(h => h.toLowerCase().startsWith(fieldName.toLowerCase()));
      if (idx !== -1) return idx;
      
      // Priority 4: Try starts-with match for friendly name
      if (friendlyName) {
        idx = headers.findIndex(h => h.toLowerCase().startsWith(friendlyName.toLowerCase()));
        if (idx !== -1) return idx;
      }
      
      // Priority 5: Try contains match for field name
      idx = headers.findIndex(h => h.toLowerCase().includes(fieldName.toLowerCase()));
      if (idx !== -1) return idx;
      
      // Priority 6: Try contains match for friendly name
      if (friendlyName) {
        idx = headers.findIndex(h => h.toLowerCase().includes(friendlyName.toLowerCase()));
        if (idx !== -1) return idx;
      }
      
      return -1;
    }
    
    // Helper to sum numeric column WITH proper unit conversion
    function sumColumnWithConversion(rows, colIdx) {
      if (colIdx === -1) return 0;
      let totalBytes = 0;
      
      for (const row of rows) {
        const rawVal = row[colIdx];
        const parsed = parseOntapNumber(rawVal);
        if (Number.isFinite(parsed.value) && parsed.detectedUnit !== "percent") {
          // parseOntapNumber already converts to bytes for values with suffixes
          // For plain numbers, assume bytes (raw)
          totalBytes += parsed.value;
        }
      }
      
      return totalBytes;
    }
    
    // Helper to format bytes
    function formatBytes(bytes, decimals = 2) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(decimals)) + ' ' + sizes[i];
    }
    
    // Get custom report values from inputs
    const reportTitle = el("reportTitle").value || "NetApp Storage Configuration Report";
    const customerName = el("reportCustomerName").value || "";
    const generatedBy = el("reportGeneratedBy").value || "CSI Ltd";
    
    // Format date as DD/MM/YYYY
    const now = new Date();
    const day = String(now.getDate()).padStart(2, '0');
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const year = now.getFullYear();
    const dateStr = `${day}/${month}/${year}`;
    
    // Title
    doc.setFontSize(18);
    doc.setFont(undefined, 'bold');
    doc.text(reportTitle, margin, yPos);
    yPos += 8;
    
    // Customer Name (if provided)
    if (customerName) {
      doc.setFontSize(14);
      doc.setFont(undefined, 'normal');
      doc.text(customerName, margin, yPos);
      yPos += 8;
    }
    
    // Prepared by line
    doc.setFontSize(10);
    doc.setFont(undefined, 'normal');
    doc.text(`Prepared by ${generatedBy} on ${dateStr}`, margin, yPos);
    yPos += 12;
    
    // === AGGREGATES SUMMARY ===
    addSectionHeader("Aggregates Summary");
    
    const aggSpaceData = parseData("pasteAggSpace");
    const aggEffData = parseData("pasteAggEfficiency");
    
    // Count aggregates
    const aggCount = aggSpaceData.rows.length || aggEffData.rows.length;
    addLineWithDesc("Total Aggregates", aggCount || "No data", "Number of storage aggregates in the cluster.");
    
    // Aggregate sizes from show-space
    let totalSize = 0, totalUsed = 0, physUsed = 0, volFootprints = 0, snapSizeTotal = 0, percentSnapshotSpace = 0;
    if (aggSpaceData.rows.length > 0) {
      const sizeCol = findColWithCatalog(aggSpaceData.headers, "aggregate-size", "fieldsAggSpace");
      const usedCol = findColWithCatalog(aggSpaceData.headers, "used-including-snapshot-reserve", "fieldsAggSpace");
      const physUsedCol = findColWithCatalog(aggSpaceData.headers, "physical-used", "fieldsAggSpace");
      const volFootprintsCol = findColWithCatalog(aggSpaceData.headers, "volume-footprints", "fieldsAggSpace");
      const snapSizeTotalCol = findColWithCatalog(aggSpaceData.headers, "snap-size-total", "fieldsAggSpace");
      const percentSnapCol = findColWithCatalog(aggSpaceData.headers, "percent-snapshot-space", "fieldsAggSpace");
      
      if (sizeCol !== -1) {
        totalSize = sumColumnWithConversion(aggSpaceData.rows, sizeCol);
        addLineWithDesc("Total Aggregate Capacity", formatBytes(totalSize), "Total raw storage capacity of all aggregates.");
      }
      if (usedCol !== -1) {
        totalUsed = sumColumnWithConversion(aggSpaceData.rows, usedCol);
        addLineWithDesc("Total Used Space (Logical)", formatBytes(totalUsed), "Logical space consumed including snapshot reserve.");
      }
      if (physUsedCol !== -1) {
        physUsed = sumColumnWithConversion(aggSpaceData.rows, physUsedCol);
        addLineWithDesc("Total Physical Used", formatBytes(physUsed), "Physical space on disk after storage efficiency savings.");
      }
      
      // Extract snapshot-related data
      if (volFootprintsCol !== -1) {
        volFootprints = sumColumnWithConversion(aggSpaceData.rows, volFootprintsCol);
      }
      if (snapSizeTotalCol !== -1) {
        snapSizeTotal = sumColumnWithConversion(aggSpaceData.rows, snapSizeTotalCol);
      }
      if (percentSnapCol !== -1 && aggSpaceData.rows.length > 0) {
        // Average the percentage across aggregates
        let totalPercent = 0;
        let count = 0;
        for (const row of aggSpaceData.rows) {
          const val = row[percentSnapCol];
          if (val && val.trim()) {
            const num = parseFloat(val);
            if (!isNaN(num)) {
              totalPercent += num;
              count++;
            }
          }
        }
        if (count > 0) {
          percentSnapshotSpace = totalPercent / count;
        }
      }
      
      // Add aggregate capacity chart if we have data
      if (totalSize > 0 && totalUsed > 0) {
        const availSpace = totalSize - totalUsed;
        addChart({
          type: 'pie',
          data: {
            labels: ['Used Space', 'Available Space'],
            datasets: [{
              data: [totalUsed, availSpace > 0 ? availSpace : 0],
              backgroundColor: ['#FF6384', '#36A2EB']
            }]
          },
          options: {
            responsive: true,
            plugins: {
              title: {
                display: true,
                text: 'Aggregate Capacity Breakdown'
              },
              legend: {
                position: 'bottom'
              }
            }
          }
        }, 160, 100);
      }
    }
    
    yPos += 6;
    
    // === SPACE BREAKDOWN & SNAPSHOTS ===
    if (aggSpaceData.rows.length > 0 && (volFootprints > 0 || snapSizeTotal > 0 || totalUsed > 0)) {
      addSectionHeader("Space Breakdown & Snapshots");
      
      if (totalUsed > 0) {
        addLineWithDesc("Total Used (Logical)", formatBytes(totalUsed), 
          "Logical space including snapshot reserve and volume data.");
      }
      
      if (volFootprints > 0) {
        addLineWithDesc("Volume Footprints", formatBytes(volFootprints), 
          "Space used by volume data (excluding snapshots).");
      }
      
      if (snapSizeTotal > 0) {
        addLineWithDesc("Snapshot Space", formatBytes(snapSizeTotal), 
          "Space consumed by snapshot copies.");
      }
      
      if (percentSnapshotSpace > 0) {
        addLineWithDesc("Snapshot Reserve %", percentSnapshotSpace.toFixed(1) + "%", 
          "Percentage of aggregate reserved for snapshots.");
      }
      
      // Add explanatory note about snapshots (plain text)
      yPos += 2;
      addDescription("Total Used includes volume data, snapshot copies, and metadata.");
      
      yPos += 6;
    }
    
    // === STORAGE EFFICIENCY & DATA REDUCTION ===
    // Try to get efficiency data from aggEffData first, then fallback to calculating from aggSpaceData
    let hasEfficiencyData = false;
    let storageEffRatio = "N/A";
    let dataReductionRatio = "N/A";
    let volLogicalUsed = 0;
    let volPhysicalUsed = 0;
    let dedupSavedRatio = "N/A";
    let compSavedRatio = "N/A";
    let isEstimated = false;
    
    if (aggEffData.rows.length > 0) {
      // Try to get data from efficiency paste using FIELD_CATALOG
      const ratioCol = findColWithCatalog(aggEffData.headers, "total-storage-efficiency-ratio", "fieldsAggEfficiency");
      const dataReductionCol = findColWithCatalog(aggEffData.headers, "total-data-reduction-efficiency-ratio-wo-snapshots", "fieldsAggEfficiency");
      const volLogicalCol = findColWithCatalog(aggEffData.headers, "volume-logical-used", "fieldsAggEfficiency");
      const volPhysicalCol = findColWithCatalog(aggEffData.headers, "volume-physical-used", "fieldsAggEfficiency");
      const dedupRatioCol = findColWithCatalog(aggEffData.headers, "volume-efficiency-saved-ratio", "fieldsAggEfficiency");
      const compRatioCol = findColWithCatalog(aggEffData.headers, "volume-compression-saved-ratio", "fieldsAggEfficiency");
      
      // For multiple aggregates, sum the logical and physical used
      for (let i = 0; i < aggEffData.rows.length; i++) {
        const row = aggEffData.rows[i];
        
        // Get ratio from first row
        if (i === 0) {
          if (ratioCol !== -1 && row[ratioCol]) {
            storageEffRatio = row[ratioCol];
            hasEfficiencyData = true;
          }
          if (dataReductionCol !== -1 && row[dataReductionCol]) {
            dataReductionRatio = row[dataReductionCol];
            hasEfficiencyData = true;
          }
          if (dedupRatioCol !== -1 && row[dedupRatioCol]) {
            dedupSavedRatio = row[dedupRatioCol];
          }
          if (compRatioCol !== -1 && row[compRatioCol]) {
            compSavedRatio = row[compRatioCol];
          }
        }
        
        // Sum logical and physical used
        if (volLogicalCol !== -1) {
          const parsed = parseOntapNumber(row[volLogicalCol]);
          if (Number.isFinite(parsed.value)) {
            volLogicalUsed += parsed.value;
          }
        }
        if (volPhysicalCol !== -1) {
          const parsed = parseOntapNumber(row[volPhysicalCol]);
          if (Number.isFinite(parsed.value)) {
            volPhysicalUsed += parsed.value;
          }
        }
      }
    } else if (aggSpaceData.rows.length > 0 && totalUsed > 0 && physUsed > 0) {
      // Fallback: calculate efficiency from aggSpaceData
      volLogicalUsed = totalUsed;
      volPhysicalUsed = physUsed;
      const efficiencyRatio = (totalUsed / physUsed).toFixed(2);
      storageEffRatio = `${efficiencyRatio}:1`;
      hasEfficiencyData = true;
      isEstimated = true;
    }
    
    // Only show storage efficiency section if we have data
    if (hasEfficiencyData || volLogicalUsed > 0 || volPhysicalUsed > 0) {
      addSectionHeader("Storage Efficiency & Data Reduction");
      
      if (isEstimated) {
        addDescription("Efficiency ratio estimated from used space data.");
      }
      
      // Display metrics only if they have values
      if (storageEffRatio !== "N/A") {
        addLineWithDesc("Storage Efficiency Ratio", storageEffRatio, "Overall ratio of logical to physical data.");
      }
      
      if (dataReductionRatio !== "N/A") {
        addLineWithDesc("Data Reduction Ratio (excl. snapshots)", dataReductionRatio, 
          "Data reduction from deduplication and compression.");
      }
      
      if (volLogicalUsed > 0) {
        addLineWithDesc("Logical Data (Backup Source Size)", formatBytes(volLogicalUsed), 
          "Total logical data size - use this for backup capacity planning.");
      }
      
      if (volPhysicalUsed > 0) {
        addLineWithDesc("Physical Data (On Disk)", formatBytes(volPhysicalUsed), 
          "Actual space consumed after storage efficiency.");
      }
      
      // Calculate savings
      if (volLogicalUsed > 0 && volPhysicalUsed > 0) {
        const spaceSaved = volLogicalUsed - volPhysicalUsed;
        const savingsPercent = ((spaceSaved / volLogicalUsed) * 100).toFixed(1);
        addLine("Total Space Saved", `${formatBytes(spaceSaved)} (${savingsPercent}%)`);
      }
      
      if (dedupSavedRatio !== "N/A") {
        addLine("Space Saved by Deduplication", dedupSavedRatio);
      }
      
      if (compSavedRatio !== "N/A") {
        addLine("Space Saved by Compression", compSavedRatio);
      }
      
      // Add chart showing logical vs physical storage
      if (volLogicalUsed > 0 && volPhysicalUsed > 0) {
        yPos += 4;
        addChart({
          type: 'bar',
          data: {
            labels: ['Storage Usage'],
            datasets: [
              {
                label: 'Logical Data',
                data: [volLogicalUsed],
                backgroundColor: '#FF6384'
              },
              {
                label: 'Physical Data',
                data: [volPhysicalUsed],
                backgroundColor: '#36A2EB'
              }
            ]
          },
          options: {
            responsive: true,
            plugins: {
              title: {
                display: true,
                text: 'Logical vs Physical Storage'
              },
              legend: {
                position: 'bottom'
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                ticks: {
                  callback: function(value) {
                    return formatBytes(value);
                  }
                }
              }
            }
          }
        }, 160, 100);
      }
      
      yPos += 6;
    }
    
    // === STORAGE EFFICIENCY BY AGGREGATE ===
    // Display efficiency ratios for each aggregate separately (not averaged)
    if (aggEffData.rows.length > 0) {
      addSectionHeader("Storage Efficiency by Aggregate");
      
      // Find the column indices using FIELD_CATALOG for both field name and friendly name
      const aggNameCol = findColWithCatalog(aggEffData.headers, "aggregate", "fieldsAggEfficiency");
      const totalEffRatioCol = findColWithCatalog(aggEffData.headers, "total-storage-efficiency-ratio", "fieldsAggEfficiency");
      const dataReductionRatioCol = findColWithCatalog(aggEffData.headers, "total-data-reduction-efficiency-ratio-wo-snapshots", "fieldsAggEfficiency");
      
      // Check if we have the required columns
      if (aggNameCol !== -1 && (totalEffRatioCol !== -1 || dataReductionRatioCol !== -1)) {
        // Loop through each aggregate and display its efficiency ratios
        for (let i = 0; i < aggEffData.rows.length; i++) {
          const row = aggEffData.rows[i];
          const aggName = row[aggNameCol] || `Aggregate ${i + 1}`;
          
          // Add aggregate name
          if (yPos > 265) {
            doc.addPage();
            yPos = 20;
          }
          doc.setFont(undefined, 'bold');
          doc.text(`Aggregate: ${aggName}`, margin + 2, yPos);
          yPos += 6;
          doc.setFont(undefined, 'normal');
          
          // Add efficiency ratios with indentation
          if (totalEffRatioCol !== -1 && row[totalEffRatioCol]) {
            const effRatioValue = row[totalEffRatioCol];
            addLine("  - With Snapshots", effRatioValue);
          }
          
          if (dataReductionRatioCol !== -1 && row[dataReductionRatioCol]) {
            const dataRedRatioValue = row[dataReductionRatioCol];
            addLine("  - Without Snapshots", dataRedRatioValue);
          }
          
          yPos += 2; // Add small space between aggregates
        }
        
        yPos += 4;
      } else {
        addDescription("Storage efficiency data columns not found.");
        yPos += 6;
      }
    }
    
    // === VOLUMES SUMMARY ===
    addSectionHeader("Volumes Summary");
    
    const volData = parseData("pasteVol");
    addLineWithDesc("Total Volumes", volData.rows.length || "No data", "Number of volumes in the cluster.");
    
    if (volData.rows.length > 0) {
      const sizeCol = findCol(volData.headers, "size");
      const usedCol = findCol(volData.headers, "used");
      const availCol = findCol(volData.headers, "available");
      const pctUsedCol = findCol(volData.headers, "percent-used");
      
      if (sizeCol !== -1) {
        const totalSize = sumColumnWithConversion(volData.rows, sizeCol);
        addLineWithDesc("Total Volume Capacity", formatBytes(totalSize), "Total provisioned capacity of all volumes.");
      }
      if (usedCol !== -1) {
        const totalUsed = sumColumnWithConversion(volData.rows, usedCol);
        addLineWithDesc("Total Used Space (Logical)", formatBytes(totalUsed), "Logical space used across all volumes.");
      }
      if (availCol !== -1) {
        const totalAvail = sumColumnWithConversion(volData.rows, availCol);
        addLineWithDesc("Total Available Space", formatBytes(totalAvail), "Total available space across all volumes.");
      }
      
      // Count by type if available
      const typeCol = findCol(volData.headers, "type", "volume-style");
      if (typeCol !== -1) {
        const types = {};
        volData.rows.forEach(row => {
          const t = row[typeCol] || "unknown";
          types[t] = (types[t] || 0) + 1;
        });
        Object.entries(types).forEach(([type, count]) => {
          addLine(`  - ${type} volumes`, count);
        });
      }
    }
    
    yPos += 6;
    
    // === VOLUME SPACE SUMMARY ===
    const volSpaceData = parseData("pasteVolSpace");
    if (volSpaceData.rows.length > 0) {
      addSectionHeader("Volume Space Details");
      addLineWithDesc("Volumes with space data", volSpaceData.rows.length, "Number of volumes with detailed space information.");
      
      const logUsedCol = findCol(volSpaceData.headers, "logical-used");
      const physUsedCol = findCol(volSpaceData.headers, "physical-used");
      
      if (logUsedCol !== -1) {
        const totalLogical = sumColumnWithConversion(volSpaceData.rows, logUsedCol);
        addLineWithDesc("Total Logical Used", formatBytes(totalLogical), "Logical space used before storage efficiency.");
      }
      if (physUsedCol !== -1) {
        const totalPhysical = sumColumnWithConversion(volSpaceData.rows, physUsedCol);
        addLineWithDesc("Total Physical Used", formatBytes(totalPhysical), "Physical space after deduplication and compression.");
      }
      yPos += 6;
    }
    
    // === SNAPSHOTS SUMMARY ===
    const snapData = parseData("pasteSnaps");
    if (snapData.rows.length > 0) {
      addSectionHeader("Snapshots Summary");
      addLineWithDesc("Total Snapshots", snapData.rows.length, "Number of snapshot copies in the system.");
      
      const sizeCol = findCol(snapData.headers, "size");
      if (sizeCol !== -1) {
        const totalSize = sumColumnWithConversion(snapData.rows, sizeCol);
        addLineWithDesc("Total Snapshot Size", formatBytes(totalSize), "Total space consumed by snapshot copies.");
      }
      yPos += 6;
    }
    
    // === EFFICIENCY SUMMARY ===
    const effData = parseData("pasteEff");
    if (effData.rows.length > 0) {
      addSectionHeader("Volume Efficiency Summary");
      addLineWithDesc("Volumes with efficiency data", effData.rows.length, "Number of volumes with efficiency information.");
      
      const stateCol = findCol(effData.headers, "state");
      if (stateCol !== -1) {
        const enabled = effData.rows.filter(r => r[stateCol]?.toLowerCase() === "enabled").length;
        const disabled = effData.rows.filter(r => r[stateCol]?.toLowerCase() === "disabled").length;
        addLine("  - Efficiency Enabled", enabled);
        addLine("  - Efficiency Disabled", disabled);
      }
      yPos += 6;
    }
    
    // === QTREES SUMMARY ===
    const qtreeData = parseData("pasteQtree");
    if (qtreeData.rows.length > 0) {
      addSectionHeader("Qtrees Summary");
      addLineWithDesc("Total Qtrees", qtreeData.rows.length, "Number of qtrees (quota trees) in the system.");
      yPos += 6;
    }
    
    // === LUNS SUMMARY ===
    const lunData = parseData("pasteLun");
    let lunUsedSpace = 0;  // Track LUN used space for informational purposes in backup planning
    if (lunData.rows.length > 0) {
      addSectionHeader("LUNs Summary");
      addLineWithDesc("Total LUNs", lunData.rows.length, "Number of LUNs (Logical Unit Numbers) for block storage.");
      
      const sizeCol = findCol(lunData.headers, "size");
      const usedCol = findCol(lunData.headers, "size-used");
      
      if (sizeCol !== -1) {
        const totalSize = sumColumnWithConversion(lunData.rows, sizeCol);
        addLineWithDesc("Total LUN Capacity", formatBytes(totalSize), "Total provisioned LUN capacity.");
      }
      if (usedCol !== -1) {
        const totalUsed = sumColumnWithConversion(lunData.rows, usedCol);
        lunUsedSpace = totalUsed;  // Save LUN used space for backup planning section
        addLineWithDesc("Total LUN Used (Logical)", formatBytes(totalUsed), "Logical space used by LUNs.");
      }
      yPos += 6;
    }
    
    // === CIFS SHARES SUMMARY ===
    const cifsData = parseData("pasteCifs");
    if (cifsData.rows.length > 0) {
      addSectionHeader("CIFS/SMB Shares Summary");
      addLineWithDesc("Total Shares", cifsData.rows.length, "Number of CIFS/SMB network file shares.");
      yPos += 6;
    }
    
    // === BACKUP PLANNING ===
    addSectionHeader("Backup Planning");
    
    // Add main instruction
    doc.setFontSize(10);
    doc.setFont(undefined, 'normal');
    doc.text("For backup capacity planning, use the LOGICAL data size.", margin, yPos);
    yPos += 8;
    
    // Calculate backup source size using volume logical used (LUNs are inside volumes, already counted)
    const backupSourceSize = volLogicalUsed;
    
    // Add recommended backup size
    if (backupSourceSize > 0) {
      doc.setFont(undefined, 'bold');
      doc.text(`Recommended backup source size: ${formatBytes(backupSourceSize)}`, margin, yPos);
      yPos += 10;
      doc.setFont(undefined, 'normal');
      
      // Add breakdown showing volume space is the source
      doc.text(`This is based on Volume Logical Used Space:`, margin, yPos);
      yPos += 6;
      doc.text(`- Volume Logical Used: ${formatBytes(volLogicalUsed)}`, margin + 2, yPos);
      yPos += 5;
      
      // Show LUN space for informational purposes only
      if (lunUsedSpace > 0) {
        doc.text(`- LUN Space (included in volume total): ${formatBytes(lunUsedSpace)}`, margin + 2, yPos);
        yPos += 5;
      }
      yPos += 4;
    } else {
      doc.text("Recommended backup source size: No data available", margin, yPos);
      yPos += 10;
    }
    
    // Check for page overflow before long section
    if (yPos > 220) {
      doc.addPage();
      yPos = 20;
    }
    
    // Add "Why use logical data?" section
    doc.setFont(undefined, 'bold');
    doc.text("Why use logical data?", margin, yPos);
    yPos += 6;
    doc.setFont(undefined, 'normal');
    
    // Add explanation paragraphs
    const explanation1 = "Backups capture the logical data as seen by applications, not the physical on-disk representation. Storage efficiency features like deduplication and compression reduce physical storage but do not reduce the data that needs to be backed up.";
    const lines1 = doc.splitTextToSize(explanation1, pageWidth - 2 * margin);
    doc.text(lines1, margin, yPos);
    yPos += lines1.length * 5 + 3;
    
    const explanation2 = "Logical data represents the actual application data before storage efficiency is applied. This is what backup software will read and transfer.";
    const lines2 = doc.splitTextToSize(explanation2, pageWidth - 2 * margin);
    doc.text(lines2, margin, yPos);
    yPos += lines2.length * 5 + 3;
    
    const explanation3 = "Physical data represents the space consumed on disk after deduplication and compression. This is smaller than logical due to storage efficiency savings.";
    const lines3 = doc.splitTextToSize(explanation3, pageWidth - 2 * margin);
    doc.text(lines3, margin, yPos);
    yPos += lines3.length * 5 + 3;
    
    const explanation4 = "Note: LUNs (Logical Unit Numbers for block storage) reside inside volumes, so volume logical used space already includes all LUN data. LUN space is shown separately for reference but should not be added to volume space.";
    const lines4 = doc.splitTextToSize(explanation4, pageWidth - 2 * margin);
    doc.text(lines4, margin, yPos);
    yPos += lines4.length * 5 + 6;
    
    // Check for page overflow before summary
    if (yPos > 250) {
      doc.addPage();
      yPos = 20;
    }
    
    // Add summary section
    doc.setFont(undefined, 'bold');
    doc.text("Summary:", margin, yPos);
    yPos += 6;
    doc.setFont(undefined, 'normal');
    
    if (volLogicalUsed > 0) {
      doc.text(`- Volume Logical Used: ${formatBytes(volLogicalUsed)} - Use this for backup sizing`, margin + 2, yPos);
      yPos += 5;
    }
    
    if (volPhysicalUsed > 0) {
      doc.text(`- Volume Physical Used: ${formatBytes(volPhysicalUsed)} - Actual disk consumption`, margin + 2, yPos);
      yPos += 5;
    }
    
    if (volLogicalUsed > 0 && volPhysicalUsed > 0 && volLogicalUsed >= volPhysicalUsed) {
      const savingsAmount = volLogicalUsed - volPhysicalUsed;
      const savingsPercent = ((savingsAmount / volLogicalUsed) * 100).toFixed(0);
      doc.text(`- Efficiency Savings: ${formatBytes(savingsAmount)} (${savingsPercent}%)`, margin + 2, yPos);
      yPos += 5;
    }
    
    yPos += 6;
    
    // Save the PDF
    doc.save("netapp_storage_report.pdf");
    
    } catch (error) {
      console.error("PDF generation error:", error);
      alert("Error generating PDF report: " + error.message);
    }
  }

  // --- Offline file import into a textarea ---
  function importFileInto(textareaId, file) {
    if (!file) {
      alert("Choose a file first.");
      return;
    }
    const reader = new FileReader();
    reader.onload = () => {
      el(textareaId).value = String(reader.result || "");
      refreshChartColumns();
      updateUnitBadge(textareaId);
      alert(`Imported into ${textareaId}.`);
    };
    reader.onerror = () => alert("Failed to read file.");
    reader.readAsText(file);
  }

  // --- Charting ---
  let chartInstance = null;

  // Textarea IDs for all paste sections
  const PASTE_TEXTAREA_IDS = [
    "pasteAggSpace", "pasteAggEfficiency",
    "pasteVol", "pasteVolSpace", "pasteSnaps", "pasteEff",
    "pasteQtree", "pasteLun", "pasteCifs"
  ];

  function parseOntapNumber(raw) {
    if (raw == null) return { value: NaN, detectedUnit: null };
    let s = String(raw).trim();
    if (!s) return { value: NaN, detectedUnit: null };

    s = s.replace(/,/g, "");

    // Handle percentages separately - no unit conversion needed
    if (s.endsWith("%")) {
      const n = parseFloat(s.slice(0, -1));
      return { value: Number.isFinite(n) ? n : NaN, detectedUnit: "percent" };
    }

    // Check for unit suffix
    const m = s.match(/^(-?\d+(?:\.\d+)?)(?:\s*([KMGTP]B))?$/i);
    if (m) {
      const num = parseFloat(m[1]);
      if (!Number.isFinite(num)) return { value: NaN, detectedUnit: null };
      
      const unitSuffix = m[2] ? m[2].toUpperCase() : null;
      
      if (unitSuffix) {
        // Value has a unit suffix - convert to bytes and note it was converted
        const mult = unitSuffix === "KB" ? 1024 :
                     unitSuffix === "MB" ? 1024**2 :
                     unitSuffix === "GB" ? 1024**3 :
                     unitSuffix === "TB" ? 1024**4 :
                     unitSuffix === "PB" ? 1024**5 : 1;
        return { value: num * mult, detectedUnit: "bytes" }; // Already in bytes
      } else {
        // Plain number - no unit suffix, needs user to specify what it represents
        return { value: num, detectedUnit: null };
      }
    }

    const n = parseFloat(s);
    return { value: Number.isFinite(n) ? n : NaN, detectedUnit: null };
  }

  /**
   * Detect the predominant unit used in size columns of pasted data
   */
  function detectDataUnit(textareaId) {
    const text = el(textareaId).value;
    if (!text.trim()) return { unit: "none", label: "No data" };
    
    const delimiter = normDelimiter(el("delimiter").value);
    const aoa = parseDelimited(text, delimiter);
    
    if (aoa.length < 2) return { unit: "none", label: "No data" };
    
    const headers = aoa[0].map(h => String(h).trim().toLowerCase());
    const dataRows = aoa.slice(1);
    
    // Find size-related columns
    const sizeKeywords = ["size", "used", "available", "avail", "total", "space", "capacity", "footprint", "saved"];
    const sizeColIdxs = headers.map((h, i) => {
      const isSizeCol = sizeKeywords.some(kw => h.includes(kw)) && !h.includes("percent");
      return isSizeCol ? i : -1;
    }).filter(i => i >= 0);
    
    if (sizeColIdxs.length === 0) return { unit: "none", label: "No size cols" };
    
    // Count unit occurrences
    const unitCounts = { raw: 0, KB: 0, MB: 0, GB: 0, TB: 0, PB: 0 };
    
    for (const row of dataRows) {
      for (const colIdx of sizeColIdxs) {
        const val = String(row[colIdx] || "").trim().toUpperCase();
        if (!val || val === "-") continue;
        
        if (val.endsWith("PB")) unitCounts.PB++;
        else if (val.endsWith("TB")) unitCounts.TB++;
        else if (val.endsWith("GB")) unitCounts.GB++;
        else if (val.endsWith("MB")) unitCounts.MB++;
        else if (val.endsWith("KB")) unitCounts.KB++;
        else if (/^-?\d+(?:\.\d+)?$/.test(val)) unitCounts.raw++;
      }
    }
    
    // Find predominant unit
    const entries = Object.entries(unitCounts).filter(([k, v]) => v > 0);
    if (entries.length === 0) return { unit: "none", label: "No size data" };
    
    const sorted = entries.sort((a, b) => b[1] - a[1]);
    const topUnit = sorted[0][0];
    const topCount = sorted[0][1];
    const total = entries.reduce((s, [k, v]) => s + v, 0);
    
    if (entries.length > 1 && topCount / total < 0.8) {
      return { unit: "mixed", label: "Mixed units" };
    }
    
    if (topUnit === "raw") {
      return { unit: "raw", label: "Raw (bytes)" };
    }
    return { unit: topUnit, label: topUnit };
  }

  function updateUnitBadge(textareaId) {
    const badge = document.getElementById(`unitBadge_${textareaId}`);
    if (!badge) return;
    
    const detected = detectDataUnit(textareaId);
    badge.textContent = detected.label;
    badge.className = "unit-badge";
    if (detected.unit === "none") badge.classList.add("none");
    else if (detected.unit === "raw") badge.classList.add("raw");
  }

  function updateAllUnitBadges() {
    PASTE_TEXTAREA_IDS.forEach(id => updateUnitBadge(id));
  }

  // Unit multipliers relative to bytes (raw) for conversion
  const UNIT_MULTIPLIERS = {
    "raw": 1,
    "KB": 1024,
    "MB": 1024 * 1024,
    "GB": 1024 * 1024 * 1024,
    "TB": 1024 * 1024 * 1024 * 1024,
    "PB": 1024 * 1024 * 1024 * 1024 * 1024
  };

  /**
   * Convert a numeric value from one storage unit to another
   * @param {number} value - The numeric value to convert
   * @param {string} fromUnit - Source unit: "none", "raw", "KB", "MB", "GB", "TB", "PB"
   * @param {string} toUnit - Target unit: "none", "raw", "KB", "MB", "GB", "TB", "PB"
   * @returns {number} The converted value
   */
  function convertUnit(value, fromUnit, toUnit) {
    if (fromUnit === "none" || toUnit === "none" || fromUnit === toUnit) {
      return value;
    }
    
    // Validate units
    if (!UNIT_MULTIPLIERS[fromUnit] || !UNIT_MULTIPLIERS[toUnit]) {
      console.warn(`Invalid unit conversion: ${fromUnit} to ${toUnit}`);
      return value;
    }
    
    // Convert to bytes first, then to target unit
    const bytesValue = value * UNIT_MULTIPLIERS[fromUnit];
    const convertedValue = bytesValue / UNIT_MULTIPLIERS[toUnit];
    
    return convertedValue;
  }

  function refreshChartColumns() {
    const delimiter = normDelimiter(el("delimiter").value);
    const srcId = el("chartSource").value;
    const aoa = parseDelimited(el(srcId).value, delimiter);

    const labelSel = el("chartLabelCol");
    const valueSel = el("chartValueCol");

    labelSel.innerHTML = "";
    valueSel.innerHTML = "";

    if (!aoa.length) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "(paste/import data first)";
      labelSel.appendChild(opt.cloneNode(true));
      valueSel.appendChild(opt);
      return;
    }

    const headers = aoa[0].map(h => h.trim());
    headers.forEach(h => {
      const o1 = document.createElement("option");
      o1.value = h;
      o1.textContent = h;
      labelSel.appendChild(o1);

      const o2 = document.createElement("option");
      o2.value = h;
      o2.textContent = h;
      valueSel.appendChild(o2);
    });

    const preferLabel =
      headers.includes("volume") ? "volume" :
      headers.includes("lun") ? "lun" :
      headers.includes("path") ? "path" :
      headers.includes("aggregate") ? "aggregate" :
      headers.includes("share-name") ? "share-name" :
      headers[0];

    const preferValue =
      headers.includes("percent-used") ? "percent-used" :
      headers.includes("logical-used-percent") ? "logical-used-percent" :
      headers.includes("total-used-percent") ? "total-used-percent" :
      headers.includes("used") ? "used" :
      headers.includes("logical-used") ? "logical-used" :
      headers.includes("total-used") ? "total-used" :
      headers.includes("size-used") ? "size-used" :
      headers.includes("size-used-by-snapshots") ? "size-used-by-snapshots" :
      headers[1] || headers[0];

    labelSel.value = preferLabel;
    valueSel.value = preferValue;
  }

  function buildChart() {
    if (!ensureOfflineLibs()) {
      alert("Missing offline library: Chart.js. Put chart.umd.min.js next to this HTML and refresh.");
      return;
    }

    const delimiter = normDelimiter(el("delimiter").value);
    const srcId = el("chartSource").value;
    const aoa = parseDelimited(el(srcId).value, delimiter);
    const status = el("chartStatus");

    if (aoa.length < 2) {
      status.textContent = "No data: paste/import a header row + at least one data row.";
      return;
    }

    const headers = aoa[0].map(h => h.trim());
    const labelCol = el("chartLabelCol").value;
    const valueCol = el("chartValueCol").value;

    const li = headers.indexOf(labelCol);
    const vi = headers.indexOf(valueCol);

    if (li < 0 || vi < 0) {
      status.textContent = "Pick valid label/value columns.";
      return;
    }

    // Get unit conversion settings
    const fromUnit = el("chartUnitFrom").value;
    const toUnit = el("chartUnitTo").value;

    const rows = aoa.slice(1).map(r => {
      const labelVal = (r[li] ?? "").trim();
      const parsed = parseOntapNumber(r[vi]);
      return {
        label: labelVal,
        rawValue: parsed.value,
        detectedUnit: parsed.detectedUnit
      };
    })
    .filter(x => x.label.length > 0 && Number.isFinite(x.rawValue))
    .map(x => {
      let finalValue = x.rawValue;
      
      // Skip conversion for percentages
      if (x.detectedUnit === "percent") {
        return { label: x.label, value: finalValue };
      }
      
      // Determine the actual source unit
      let actualFromUnit;
      if (x.detectedUnit === "bytes") {
        // Value already converted to bytes by parseOntapNumber (had suffix like "10GB")
        actualFromUnit = "raw"; // "raw" means bytes
      } else {
        // Plain number - use user-specified fromUnit
        actualFromUnit = fromUnit;
      }
      
      // Apply conversion if needed
      if (actualFromUnit !== "none" && toUnit !== "none" && actualFromUnit !== toUnit) {
        finalValue = convertUnit(finalValue, actualFromUnit, toUnit);
      }
      
      return { label: x.label, value: finalValue };
    });

    if (!rows.length) {
      status.textContent = "No numeric values found in the selected value column.";
      return;
    }

    const sortDir = el("chartSort").value;
    rows.sort((a,b) => sortDir === "asc" ? (a.value - b.value) : (b.value - a.value));

    const topN = Math.max(1, Math.min(200, parseInt(el("chartTopN").value || "20", 10)));
    const sliced = rows.slice(0, topN);

    const labels = sliced.map(x => x.label);
    const data = sliced.map(x => x.value);

    const orientation = el("chartOrientation").value;
    const indexAxis = orientation === "horizontal" ? "y" : "x";

    if (chartInstance) {
      chartInstance.destroy();
      chartInstance = null;
    }

    // Determine label for chart
    const unitLabel = toUnit !== "none" ? ` (${toUnit})` : "";
    const chartLabel = `${valueCol} (Top ${topN})${unitLabel}`;

    const ctx = el("chartCanvas").getContext("2d");
    chartInstance = new Chart(ctx, {
      type: "bar",
      data: { labels, datasets: [{ label: chartLabel, data }] },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        indexAxis,
        plugins: {
          legend: {
            display: true,
            position: "top",
            labels: {
              color: "#e9eefc",
              font: {
                size: 12
              }
            }
          },
          tooltip: { enabled: true }
        },
        scales: {
          x: { ticks: { color: "#a9b4d6" }, grid: { color: "rgba(35,48,90,0.35)" } },
          y: { ticks: { color: "#a9b4d6" }, grid: { color: "rgba(35,48,90,0.35)" } }
        }
      }
    });

    status.textContent = `Chart built from ${srcId}: label=${labelCol}, value=${valueCol}, numeric_rows=${rows.length}.`;
  }

  function clearChart() {
    if (chartInstance) {
      chartInstance.destroy();
      chartInstance = null;
    }
    el("chartStatus").textContent = "";
  }

  /**
   * Export the current chart as a high-resolution PNG image
   * Creates a 2x scaled version with white background for better quality and printing
   * Minimum width of 1200px ensures readability
   */
  function exportChartToPng() {
    const canvas = el("chartCanvas");
    if (!chartInstance) {
      alert("No chart to export. Build a chart first.");
      return;
    }
    
    try {
      // Create a larger canvas for better resolution
      const scaleFactor = 2; // 2x resolution for crisp export
      const exportCanvas = document.createElement("canvas");
      const ctx = exportCanvas.getContext("2d");
      
      if (!ctx) {
        throw new Error("Failed to get canvas context");
      }
      
      // Ensure minimum width for readability
      const minWidth = 1200;
      const baseWidth = Math.max(canvas.width, minWidth);
      const baseHeight = canvas.height;
      
      exportCanvas.width = baseWidth * scaleFactor;
      exportCanvas.height = baseHeight * scaleFactor;
      
      // Fill with white background
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
      
      // Draw the chart at higher resolution
      ctx.scale(scaleFactor, scaleFactor);
      ctx.drawImage(canvas, 0, 0, baseWidth, baseHeight);
      
      // Create download link
      const link = document.createElement("a");
      link.download = "chart_export.png";
      link.href = exportCanvas.toDataURL("image/png", 1.0);
      link.click();
    } catch (error) {
      alert(`Failed to export chart: ${error.message}`);
      console.error("Chart export error:", error);
    }
  }

  /* =========================
     Defaults + initialization
     ========================= */

  const DEFAULT_SELECTIONS = {
    fieldsAggSpace: [
      "aggregate-name","aggregate","volume-footprints","volume-footprints-percent",
      "aggregate-metadata","aggregate-metadata-percent",
      "physical-used","physical-used-percent",
      "used-including-snapshot-reserve","used-including-snapshot-reserve-percent"
    ],
    fieldsAggEfficiency: [
      "aggregate","node","total-storage-efficiency-ratio",
      "total-data-reduction-efficiency-ratio-wo-snapshots",
      "volume-logical-used","volume-physical-used"
    ],
    fieldsVol: [
      "vserver","volume","state","size","used","available","percent-used","aggregate","node",
      "junction-path","security-style","unix-permissions","policy",
      "percent-snapshot-space","snapshot-space-used","size-used-by-snapshots",
      "logical-used","logical-used-percent","logical-available",
      "physical-used","physical-used-percent",
      "sis-space-saved","sis-space-saved-percent",
      "dedupe-space-saved","dedupe-space-saved-percent",
      "compression-space-saved","compression-space-saved-percent",
      "qos-policy-group","qos-adaptive-policy-group"
    ],
    fieldsVolSpace: [
      "vserver","volume","aggregate",
      "user-data","user-data-percent",
      "filesystem-metadata","filesystem-metadata-percent",
      "snapshot-reserve","snapshot-reserve-percent",
      "snapshot-spill","snapshot-spill-percent",
      "dedupe-metafiles","dedupe-metafiles-percent",
      "quota-metafiles","quota-metafiles-percent",
      "inodes","inodes-percent",
      "total-used","total-used-percent",
      "physical-used","physical-used-percent",
      "logical-used","logical-used-percent",
      "logical-available"
    ],
    fieldsSnaps: ["vserver","volume","snapshot","create-time","state","size","blocks","usedblocks","expiry-time","comment","snapmirror-label"],
    fieldsEff: [
      "vserver","volume","path","state","op-status","progress","policy","schedule","type",
      "compression","inline-compression","inline-dedupe","data-compaction",
      "cross-volume-inline-dedupe","cross-volume-background-dedupe",
      "storage-efficiency-mode","logical-data-size","logical-data-percent",
      "last-success-op-begin","last-success-op-end","last-op-state","last-op-error"
    ],
    fieldsQtree: ["vserver","volume","qtree","qtree-path","security-style","oplock-mode","user","group","unix-permissions","status","export-policy","is-export-policy-inherited","qos-policy-group"],
    fieldsLun: [
      "vserver","path","volume","qtree","lun","size","ostype","space-reserve","space-allocation",
      "serial","state","mapped","read-only","size-used","node","qos-policy-group","qos-adaptive-policy-group",
      "caching-policy","comment","uuid","creation-timestamp"
    ],
    fieldsCifs: ["vserver","share-name","cifs-server","path","comment","volume","share-properties","acl","offline-files","max-connections-per-share","force-group-for-create"]
  };

  let PICKERS = {};

  async function resetDefaults() {
    el("delimiter").value = ",";
    el("commentPrefix").value = "#";
    el("showAllFields").checked = true;
    el("unitsRaw").checked = true;
    el("unitsSpecifier").value = "(none)";
    el("rows0").checked = true;
    el("svm").value = "";
    el("scope").value = "whereSupported";

    await DB.del("unitsSpecifier");
    await DB.del("uiSettings");

    for (const k of Object.keys(DEFAULT_SELECTIONS)) await DB.del(k);

    for (const k of Object.keys(DEFAULT_SELECTIONS)) {
      setInputFields(k, DEFAULT_SELECTIONS[k]);
      if (PICKERS[k]) PICKERS[k].setCheckedFromList(DEFAULT_SELECTIONS[k]);
    }

    genPuttyBlock();
  }

  async function loadSelectionsAndInitPickers() {
    for (const k of Object.keys(DEFAULT_SELECTIONS)) setInputFields(k, DEFAULT_SELECTIONS[k]);

    PICKERS.fieldsAggSpace = renderPicker("fieldsAggSpace", "storage aggregate show-space");
    PICKERS.fieldsAggEfficiency = renderPicker("fieldsAggEfficiency", "storage aggregate show-efficiency");
    PICKERS.fieldsVol = renderPicker("fieldsVol", "volume show");
    PICKERS.fieldsVolSpace = renderPicker("fieldsVolSpace", "volume show-space");
    PICKERS.fieldsSnaps = renderPicker("fieldsSnaps", "volume snapshot show");
    PICKERS.fieldsEff = renderPicker("fieldsEff", "volume efficiency show");
    PICKERS.fieldsQtree = renderPicker("fieldsQtree", "volume qtree show");
    PICKERS.fieldsLun = renderPicker("fieldsLun", "lun show");
    PICKERS.fieldsCifs = renderPicker("fieldsCifs", "vserver cifs share show");

    for (const k of Object.keys(DEFAULT_SELECTIONS)) {
      const saved = await DB.get(k);
      const list = Array.isArray(saved) && saved.length ? saved : DEFAULT_SELECTIONS[k];
      const valid = new Set((FIELD_CATALOG[k] || []).map(x => x.f));
      const cleaned = list.filter(f => valid.has(f));

      setInputFields(k, cleaned);
      if (PICKERS[k]) PICKERS[k].setCheckedFromList(cleaned);
    }

    // Load saved unit preference
    const unitSaved = await DB.get("unitsSpecifier");
    if (typeof unitSaved === "string") el("unitsSpecifier").value = unitSaved;

    // Load UI settings (if present)
    const uiSaved = await DB.get("uiSettings");
    if (uiSaved && typeof uiSaved === "object") {
      if (typeof uiSaved.delimiter === "string") el("delimiter").value = uiSaved.delimiter;
      if (typeof uiSaved.commentPrefix === "string") el("commentPrefix").value = uiSaved.commentPrefix;
      if (typeof uiSaved.showAllFields === "boolean") el("showAllFields").checked = uiSaved.showAllFields;
      if (typeof uiSaved.unitsRaw === "boolean") el("unitsRaw").checked = uiSaved.unitsRaw;
      if (typeof uiSaved.rows0 === "boolean") el("rows0").checked = uiSaved.rows0;
      if (typeof uiSaved.svm === "string") el("svm").value = uiSaved.svm;
      if (typeof uiSaved.scope === "string") el("scope").value = uiSaved.scope;
    }

    genPuttyBlock();
  }

  function clearAllPastes() {
    PASTE_TEXTAREA_IDS.forEach(id => el(id).value = "");
    refreshChartColumns();
    updateAllUnitBadges();
  }

  async function copyBlock() {
    const txt = el("out").value;
    try {
      await navigator.clipboard.writeText(txt);
      alert("Copied PuTTY block!");
    } catch {
      el("out").focus();
      el("out").select();
      document.execCommand("copy");
      alert("Copied PuTTY block (fallback)!");
    }
  }

  /* =========================
     Export / Import config JSON
     - Now includes the pasted CSV/text boxes + chart UI selections
     ========================= */

  const CONFIG_KEYS = ["fieldsAggSpace","fieldsAggEfficiency","fieldsVol","fieldsVolSpace","fieldsSnaps","fieldsEff","fieldsQtree","fieldsLun","fieldsCifs"];
  const DATA_KEYS = ["pasteAggSpace","pasteAggEfficiency","pasteVol","pasteVolSpace","pasteSnaps","pasteEff","pasteQtree","pasteLun","pasteCifs"];

  function collectCurrentConfig() {
    const fields = {};
    for (const k of CONFIG_KEYS) {
      fields[k] = parseFieldList(el(k).value);
    }

    const ui = {
      delimiter: el("delimiter").value,
      commentPrefix: el("commentPrefix").value,
      showAllFields: el("showAllFields").checked,
      unitsRaw: el("unitsRaw").checked,
      unitsSpecifier: el("unitsSpecifier").value,
      rows0: el("rows0").checked,
      svm: el("svm").value,
      scope: el("scope").value
    };

    const data = {};
    for (const k of DATA_KEYS) data[k] = el(k).value || "";

    const charts = {
      chartSource: el("chartSource").value,
      chartTopN: el("chartTopN").value,
      chartLabelCol: el("chartLabelCol").value,
      chartValueCol: el("chartValueCol").value,
      chartOrientation: el("chartOrientation").value,
      chartSort: el("chartSort").value
    };

    return {
      schema: "ontap-cli-exporter-config",
      version: 1,
      exportedAt: new Date().toISOString(),
      ui,
      fields,
      data,
      charts
    };
  }

  function downloadJson(obj, filename) {
    const json = JSON.stringify(obj, null, 2);
    const blob = new Blob([json], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  async function exportFieldConfig() {
    const cfg = collectCurrentConfig();
    const stamp = new Date().toISOString().replace(/[:.]/g,"-").slice(0,19);
    downloadJson(cfg, `ontap_config_and_data_${stamp}.json`);
  }

  function isPlainObject(v) {
    return !!v && typeof v === "object" && !Array.isArray(v);
  }
  
  // Refresh all UI elements after importing JSON config
  function refreshAllAfterImport() {
    // Refresh unit badges if they exist
    if (typeof updateAllUnitBadges === 'function') {
      updateAllUnitBadges();
    }
    
    // Trigger input events on all paste textareas to refresh any listeners
    PASTE_TEXTAREA_IDS.forEach(id => {
      const textarea = el(id);
      if (textarea && textarea.value.trim()) {
        textarea.dispatchEvent(new Event('input', { bubbles: true }));
      }
    });
  }

  function filterToValidFields(key, list) {
    const valid = new Set((FIELD_CATALOG[key] || []).map(x => x.f));
    return (Array.isArray(list) ? list : [])
      .map(x => String(x).trim())
      .filter(x => valid.has(x));
  }

  async function applyImportedConfig(cfg) {
    if (!isPlainObject(cfg)) throw new Error("Invalid JSON (not an object).");
    if (cfg.schema !== "ontap-cli-exporter-config") throw new Error("Invalid schema (not an ONTAP exporter config).");
    if (cfg.version !== 1) throw new Error("Unsupported config version.");

    // UI
    const ui = cfg.ui;
    if (isPlainObject(ui)) {
      if (typeof ui.delimiter === "string") el("delimiter").value = ui.delimiter;
      if (typeof ui.commentPrefix === "string") el("commentPrefix").value = ui.commentPrefix;
      if (typeof ui.showAllFields === "boolean") el("showAllFields").checked = ui.showAllFields;
      if (typeof ui.unitsRaw === "boolean") el("unitsRaw").checked = ui.unitsRaw;
      if (typeof ui.unitsSpecifier === "string") el("unitsSpecifier").value = ui.unitsSpecifier;
      if (typeof ui.rows0 === "boolean") el("rows0").checked = ui.rows0;
      if (typeof ui.svm === "string") el("svm").value = ui.svm;
      if (typeof ui.scope === "string") el("scope").value = ui.scope;

      await DB.set("unitsSpecifier", el("unitsSpecifier").value);
      await DB.set("uiSettings", {
        delimiter: el("delimiter").value,
        commentPrefix: el("commentPrefix").value,
        showAllFields: el("showAllFields").checked,
        unitsRaw: el("unitsRaw").checked,
        rows0: el("rows0").checked,
        svm: el("svm").value,
        scope: el("scope").value
      });
    }

    // Fields
    const fobj = cfg.fields;
    if (isPlainObject(fobj)) {
      for (const k of CONFIG_KEYS) {
        if (k in fobj) {
          const cleaned = filterToValidFields(k, fobj[k]);
          setInputFields(k, cleaned);
          if (PICKERS[k]) PICKERS[k].setCheckedFromList(cleaned);
          await DB.set(k, cleaned);
        }
      }
    }

    // Pasted outputs (summary chart CSV boxes)
    const dobj = cfg.data;
    if (isPlainObject(dobj)) {
      for (const k of DATA_KEYS) {
        if (typeof dobj[k] === "string") el(k).value = dobj[k];
      }
    }

    // Chart UI settings (optional)
    const cobj = cfg.charts;
    if (isPlainObject(cobj)) {
      if (typeof cobj.chartSource === "string") el("chartSource").value = cobj.chartSource;
      if (typeof cobj.chartTopN === "string" || typeof cobj.chartTopN === "number") el("chartTopN").value = String(cobj.chartTopN);
      // label/value columns depend on data source; set after refresh
      if (typeof cobj.chartOrientation === "string") el("chartOrientation").value = cobj.chartOrientation;
      if (typeof cobj.chartSort === "string") el("chartSort").value = cobj.chartSort;
      refreshChartColumns();
      if (typeof cobj.chartLabelCol === "string") el("chartLabelCol").value = cobj.chartLabelCol;
      if (typeof cobj.chartValueCol === "string") el("chartValueCol").value = cobj.chartValueCol;
    } else {
      refreshChartColumns();
    }

    genPuttyBlock();
    
    // Refresh all UI elements after import
    refreshAllAfterImport();
  }

  async function importFieldConfigFromFile(file) {
    if (!file) return;
    const text = await file.text();
    let cfg;
    try {
      cfg = JSON.parse(text);
    } catch {
      throw new Error("Selected file is not valid JSON.");
    }
    await applyImportedConfig(cfg);
  }

  /* =========================
     Wire up UI
     ========================= */

  el("btnGenerate").addEventListener("click", genPuttyBlock);
  el("btnCopy").addEventListener("click", copyBlock);
  el("btnReset").addEventListener("click", () => { resetDefaults(); });

  el("btnExportAll").addEventListener("click", exportAll);
  el("btnGenerateReport").addEventListener("click", generatePDFReport);
  el("btnClearAll").addEventListener("click", clearAllPastes);

  document.querySelectorAll(".btnExportOne").forEach(btn => {
    btn.addEventListener("click", () => {
      const target = btn.getAttribute("data-target");
      const sheet = btn.getAttribute("data-sheet");
      exportOne(target, sheet, sheet);
    });
  });

  el("btnImport").addEventListener("click", () => {
    const target = el("importTarget").value;
    const file = el("importFile").files && el("importFile").files[0];
    importFileInto(target, file);
  });

  el("chartSource").addEventListener("change", refreshChartColumns);

  // Auto-refresh chart column dropdowns when data is pasted or typed into paste textareas
  PASTE_TEXTAREA_IDS.forEach(id => {
    const textarea = el(id);
    if (textarea) {
      // Refresh on paste event
      textarea.addEventListener("paste", () => {
        setTimeout(refreshChartColumns, 100); // Small delay to allow paste to complete
        setTimeout(() => updateUnitBadge(id), 100);
      });

      // Refresh on input event (typing, cutting, etc.) with debounce
      textarea.addEventListener("input", () => {
        clearTimeout(textarea._refreshTimeout);
        textarea._refreshTimeout = setTimeout(refreshChartColumns, 300);
        clearTimeout(textarea._unitBadgeTimeout);
        textarea._unitBadgeTimeout = setTimeout(() => updateUnitBadge(id), 300);
      });
    }
  });

  // Regenerate on settings change + persist UI settings
  const persistUiDebounced = (() => {
    let t = null;
    return () => {
      clearTimeout(t);
      t = setTimeout(async () => {
        await DB.set("uiSettings", {
          delimiter: el("delimiter").value,
          commentPrefix: el("commentPrefix").value,
          showAllFields: el("showAllFields").checked,
          unitsRaw: el("unitsRaw").checked,
          rows0: el("rows0").checked,
          svm: el("svm").value,
          scope: el("scope").value
        });
      }, 250);
    };
  })();

  el("delimiter").addEventListener("change", () => { refreshChartColumns(); regenDebounced(); persistUiDebounced(); });
  el("commentPrefix").addEventListener("change", () => { regenDebounced(); persistUiDebounced(); });
  el("showAllFields").addEventListener("change", () => { regenDebounced(); persistUiDebounced(); });

  el("rows0").addEventListener("change", () => { regenDebounced(); persistUiDebounced(); });
  el("svm").addEventListener("input", () => { regenDebounced(); persistUiDebounced(); });
  el("scope").addEventListener("change", () => { regenDebounced(); persistUiDebounced(); });

  // Units controls
  el("unitsRaw").addEventListener("change", () => { regenDebounced(); persistUiDebounced(); });
  el("unitsSpecifier").addEventListener("change", async () => {
    await DB.set("unitsSpecifier", el("unitsSpecifier").value);
    if (el("unitsSpecifier").value !== "(none)") el("unitsRaw").checked = false;
    regenDebounced();
    persistUiDebounced();
  });

  el("btnBuildChart").addEventListener("click", buildChart);
  el("btnClearChart").addEventListener("click", clearChart);
  el("btnExportChartPng").addEventListener("click", exportChartToPng);

  // Config export/import buttons
  el("btnExportConfig").addEventListener("click", exportFieldConfig);

  el("btnImportConfig").addEventListener("click", () => {
    el("configFile").value = "";
    el("configFile").click();
  });

  el("configFile").addEventListener("change", async () => {
    const file = el("configFile").files && el("configFile").files[0];
    if (!file) return;
    try {
      await importFieldConfigFromFile(file);
      alert("Imported configuration successfully.");
    } catch (e) {
      alert(`Import failed: ${e && e.message ? e.message : String(e)}`);
    }
  });

  // init
  ensureOfflineLibs();
  loadSelectionsAndInitPickers().then(() => {
    refreshChartColumns();
    updateAllUnitBadges();
  });
</script>
</body>
</html>
